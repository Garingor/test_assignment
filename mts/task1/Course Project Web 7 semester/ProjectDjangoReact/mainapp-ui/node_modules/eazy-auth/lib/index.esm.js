import { select, call, put, fork, take as take$1, cancel, delay } from 'redux-saga/effects';
import { Subject, concat, of, from, defer, throwError, empty } from 'rxjs';
import { filter, exhaustMap, map, catchError, takeUntil, publish, take, mergeMap } from 'rxjs/operators';
import React, { createElement, PureComponent } from 'react';
import { connect } from 'react-redux';
import hoistStatics from 'hoist-non-react-statics';
import { Route, Redirect } from 'react-router-dom';
import { combineReducers } from 'redux';
import { defaultMemoize } from 'reselect';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var withExtraReducer = function withExtraReducer(baseReducer, extraReducer) {
  if (typeof extraReducer === 'function') {
    return function (prevState, action) {
      return extraReducer(prevState, action, baseReducer);
    };
  }

  return baseReducer;
};
var emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i;
var isEmailValid = function isEmailValid(email) {
  return emailRegex.test(email);
};

// Namespace for eazy auth actions
var NS = '@@eazy-auth/';

var BOOTSTRAP_AUTH_START = NS + "BOOTSTRAP_AUTH_START";
var BOOTSTRAP_AUTH_END = NS + "BOOTSTRAP_AUTH_END";
var LOGIN = NS + "LOGIN";
var LOGIN_LOADING = NS + "LOGIN_LOADING";
var LOGIN_FAILURE = NS + "LOGIN_FAILURE";
var LOGIN_SUCCESS = NS + "LOGIN_SUCCESS";
var login = function login(credentials) {
  return {
    type: LOGIN,
    payload: {
      credentials: credentials
    }
  };
};
var CLEAR_LOGIN_ERROR = NS + "CLEAR_LOGIN_ERROR";
var clearLoginError = function clearLoginError() {
  return {
    type: CLEAR_LOGIN_ERROR
  };
};
var AUTH_WITH_TOKEN_LOADING = NS + "AUTH_WITH_TOKEN_LOADING";
var AUTH_WITH_TOKEN_FAILURE = NS + "AUTH_WITH_TOKEN_FAILURE";
var AUTH_WITH_TOKEN_SUCCESS = NS + "AUTH_WITH_TOKEN_SUCCESS";
var LOGOUT = NS + "LOGOUT";
var logout = function logout(options) {
  if (options === void 0) {
    options = {
      fromPermission: false
    };
  }

  return {
    type: LOGOUT,
    payload: {
      fromPermission: options.fromPermission
    }
  };
};
var TOKEN_REFRESHING = NS + "TOKEN_REFRESHING";
var tokenRefreshing = function tokenRefreshing() {
  return {
    type: TOKEN_REFRESHING
  };
};
var TOKEN_REFRESHED = NS + "TOKEN_REFRESHED";
var tokenRefreshed = function tokenRefreshed(_ref) {
  var accessToken = _ref.accessToken,
      refreshToken = _ref.refreshToken,
      _ref$expires = _ref.expires,
      expires = _ref$expires === void 0 ? null : _ref$expires;
  return {
    type: TOKEN_REFRESHED,
    payload: {
      accessToken: accessToken,
      refreshToken: refreshToken,
      expires: expires
    }
  };
};
var UPDATE_USER = NS + "UPDATE_USER";
var updateUser = function updateUser(user) {
  return {
    type: UPDATE_USER,
    payload: user
  };
};
var PATCH_USER = NS + "PATCH_USER";
var patchUser = function patchUser(partialUser) {
  return {
    type: PATCH_USER,
    payload: partialUser
  };
};

var initialState = {
  user: null,
  accessToken: null,
  refreshToken: null,
  refreshing: false,
  expires: null,
  loginLoading: false,
  loginError: null,
  bootstrappingAuth: false,
  // TODO <--- Remove
  authBooted: false,
  authenticatingWithToken: false,
  logoutFromPermission: false
};

var authReducer = function authReducer(previousState, _ref) {
  if (previousState === void 0) {
    previousState = initialState;
  }

  var type = _ref.type,
      payload = _ref.payload,
      error = _ref.error;

  switch (type) {
    case LOGIN_LOADING:
      return _extends({}, previousState, {
        loginLoading: true,
        loginError: null
      });

    case LOGIN_FAILURE:
      return _extends({}, previousState, {
        loginLoading: false,
        loginError: error
      });

    case CLEAR_LOGIN_ERROR:
      return _extends({}, previousState, {
        loginError: null
      });

    case LOGIN_SUCCESS:
      return _extends({}, previousState, {
        loginLoading: false,
        user: payload.user,
        accessToken: payload.accessToken,
        refreshToken: payload.refreshToken,
        expires: payload.expires,
        logoutFromPermission: false
      });

    case BOOTSTRAP_AUTH_START:
      return _extends({}, previousState, {
        bootstrappingAuth: true
      });

    case BOOTSTRAP_AUTH_END:
      return _extends({}, previousState, {
        authBooted: true,
        bootstrappingAuth: false
      });

    case AUTH_WITH_TOKEN_LOADING:
      return _extends({}, previousState, {
        authenticatingWithToken: true
      });

    case AUTH_WITH_TOKEN_FAILURE:
      return _extends({}, previousState, {
        refreshing: false,
        authenticatingWithToken: false
      });

    case AUTH_WITH_TOKEN_SUCCESS:
      return _extends({}, previousState, {
        refreshing: false,
        authenticatingWithToken: false,
        expires: payload.expires,
        user: payload.user,
        accessToken: payload.accessToken,
        refreshToken: payload.refreshToken
      });

    case TOKEN_REFRESHING:
      return _extends({}, previousState, {
        refreshing: true
      });

    case TOKEN_REFRESHED:
      return _extends({}, previousState, {
        refreshing: false,
        expires: payload.expires,
        accessToken: payload.accessToken,
        refreshToken: payload.refreshToken
      });

    case UPDATE_USER:
      return _extends({}, previousState, {
        user: payload
      });

    case PATCH_USER:
      return _extends({}, previousState, {
        user: _extends({}, previousState.user, payload)
      });

    case LOGOUT:
      return _extends({}, initialState, {
        authBooted: true,
        logoutFromPermission: payload.fromPermission
      });

    default:
      return previousState;
  }
};

var makeAuthReducer = function makeAuthReducer(extraReducer) {
  return withExtraReducer(authReducer, extraReducer);
};

var UNAUTHORIZED_ERROR_SHAPE = {
  status: 401,
  fromRefresh: true
};
function makeAuthMiddleware(_ref) {
  var meCall = _ref.meCall,
      loginCall = _ref.loginCall,
      refreshTokenCall = _ref.refreshTokenCall,
      storageBackend = _ref.storageBackend,
      reduxMountPoint = _ref.reduxMountPoint,
      localStorageNamespace = _ref.localStorageNamespace,
      makeErrorFromException = _ref.makeErrorFromException;
  // Redux store
  var store; // Selectors

  var selectAuth = function selectAuth(state) {
    return state[reduxMountPoint];
  }; // Storage utilities


  function lsStoreAccessToken(token) {
    var jsonToken = token === undefined ? 'null' : JSON.stringify(token);

    try {
      localStorage.setItem(localStorageNamespace + ":accessToken", jsonToken);
    } catch (e) {
      console.log('Failed to write to local storage', e);
    }
  }

  function lsStoreRefreshToken(token) {
    var jsonToken = token === undefined ? 'null' : JSON.stringify(token);

    try {
      localStorage.setItem(localStorageNamespace + ":refreshToken", jsonToken);
    } catch (e) {
      console.log('Failed to write to local storage', e);
    }
  }

  function lsStoreExpires(expires) {
    // Store along seconds timestamp...
    var timestamp = parseInt(new Date().getTime() / 1000, 10);

    try {
      localStorage.setItem('setItem', localStorageNamespace + ":expires", expires + "," + timestamp);
    } catch (e) {
      console.log('Failed to write to local storage', e);
    }
  } // Observable of redux dispatched actions


  var actionSubject$ = new Subject();
  var action$ = actionSubject$.asObservable(); // Redux middleware

  var authMiddleware = function authMiddleware(reduxStore) {
    // Save the instance of redux store
    store = reduxStore;
    return function (next) {
      return function (action) {
        actionSubject$.next(action);
        return next(action);
      };
    };
  }; // Observable that emit only on LOGOUT actions


  var logout$ = action$.pipe(filter(function (action) {
    return action.type === LOGOUT;
  })); // Subject for emit refresh tasks

  var refreshEmitter$ = new Subject();
  var refresh$ = refreshEmitter$.asObservable().pipe(exhaustMap(function (refreshToken) {
    return concat(of(tokenRefreshing()), from(refreshTokenCall(refreshToken)).pipe(map(function (refreshResponse) {
      return tokenRefreshed({
        accessToken: refreshResponse.access_token,
        refreshToken: refreshResponse.refresh_token,
        expires: refreshResponse.expires
      });
    }), catchError(function (error) {
      return of(logout());
    }), takeUntil(logout$)));
  }), publish()); // Make an Observable that complete with access token
  // when TOKEN_REFRESHED action is dispatched in redux store
  // or throw a simil 401 error when logout is dispatched
  // this can be used as 'virtual' refreshToken() api

  function waitForStoreRefreshObservable() {
    return action$.pipe(filter(function (action) {
      return action.type === TOKEN_REFRESHED || action.type === LOGOUT;
    }), take(1), mergeMap(function (action) {
      if (action.type === LOGOUT) {
        return throwError(UNAUTHORIZED_ERROR_SHAPE);
      }

      return of(action.payload.accessToken);
    }));
  } // Make an Observable taht complete token or 401 simil error


  function getAccessToken() {
    var _selectAuth = selectAuth(store.getState()),
        authBooted = _selectAuth.authBooted; // Wait eazy-auth boot ...


    var waitBoot$;

    if (!authBooted) {
      waitBoot$ = action$.pipe(filter(function (action) {
        return action.type === BOOTSTRAP_AUTH_END;
      }), take(1), mergeMap(function () {
        return empty();
      }));
    } else {
      waitBoot$ = empty();
    }

    return concat(waitBoot$, defer(function () {
      var _selectAuth2 = selectAuth(store.getState()),
          accessToken = _selectAuth2.accessToken,
          refreshing = _selectAuth2.refreshing; // Not authenticated, complete empty


      if (accessToken === null) {
        return of(null);
      } // Refresh in place wait from redux


      if (refreshing) {
        return waitForStoreRefreshObservable();
      } // Valid acces token in store!


      return of(accessToken);
    }));
  }

  function refreshOnUnauth(accessToken2Refresh) {
    var _selectAuth3 = selectAuth(store.getState()),
        refreshToken = _selectAuth3.refreshToken,
        accessToken = _selectAuth3.accessToken,
        refreshing = _selectAuth3.refreshing;

    if (accessToken === null) {
      // An error occurred but in the meanwhile
      // logout or bad refresh was happends...
      return throwError(UNAUTHORIZED_ERROR_SHAPE);
    }

    if (refreshing) {
      return waitForStoreRefreshObservable();
    }

    if (accessToken !== accessToken2Refresh) {
      // Another cool guy has refresh ma token
      // return new tokens ...
      return of(accessToken);
    } // Ok this point token match the current
    // no refresh ar in place so ....
    // start refresh!


    refreshEmitter$.next(refreshToken);
    return waitForStoreRefreshObservable();
  } // Logout from error


  function unauthLogout(badAccessToken, error) {
    var _selectAuth4 = selectAuth(store.getState()),
        accessToken = _selectAuth4.accessToken,
        refreshing = _selectAuth4.refreshing;

    if (accessToken !== null && !refreshing && accessToken === badAccessToken) {
      if (typeof error === 'object' && error.status === 401) {
        store.dispatch(logout());
      } else if (typeof error === 'object' && error.status === 403) {
        store.dispatch(logout({
          fromPermission: true
        }));
      }
    }
  }

  function onObsevableError(error, apiFn, firstAccessToken, args) {
    if (firstAccessToken !== null) {
      if (typeof refreshTokenCall !== 'function') {
        // Refresh can't be called
        // notify logout when needed give back error
        unauthLogout(firstAccessToken, error);
        return throwError(error);
      }

      if (error.status === 401) {
        // Try refresh
        return refreshOnUnauth(firstAccessToken).pipe(mergeMap(function (accessToken) {
          return from(apiFn(accessToken).apply(void 0, args)).pipe(catchError(function (error) {
            unauthLogout(accessToken, error);
            return throwError(error);
          }));
        }));
      }
    }

    return throwError(error);
  }

  function callAuthApiObservable(apiFn) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return getAccessToken().pipe(mergeMap(function (firstAccessToken) {
      return from(apiFn(firstAccessToken).apply(void 0, args)).pipe(catchError(function (error) {
        return onObsevableError(error, apiFn, firstAccessToken, args);
      }));
    }));
  }

  function callAuthApiPromise(apiFn) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return getAccessToken().toPromise().then(function (firstAccessToken) {
      return apiFn(firstAccessToken).apply(void 0, args)["catch"](function (error) {
        if (firstAccessToken !== null) {
          if (typeof refreshTokenCall !== 'function') {
            // Refresh can't be called
            unauthLogout(firstAccessToken, error);
            return Promise.reject(error);
          }

          if (error.status === 401) {
            // Try refresh
            return refreshOnUnauth(firstAccessToken).toPromise().then(function (accessToken) {
              return apiFn(accessToken).apply(void 0, args)["catch"](function (error) {
                unauthLogout(accessToken, error);
                return Promise.reject(error);
              });
            });
          }
        } // Unauthorized


        return Promise.reject(error);
      });
    });
  }

  function run() {
    if (store === undefined) {
      throw new Error("You should applyMiddleware in redux store before call run().");
    } // GioVa 1312 illegal boy


    actionSubject$.pipe(filter(function (action) {
      return action.type === BOOTSTRAP_AUTH_END;
    }), take(1)).subscribe(function () {
      refresh$.connect();
    });
    refresh$.subscribe(function (action) {
      // TODO: Maybe to other checks.... for saga problem ....
      store.dispatch(action);

      if (action.type === TOKEN_REFRESHED) {
        var payload = action.payload; // Write lo local storage!

        lsStoreAccessToken(payload.accessToken);
        lsStoreRefreshToken(payload.refreshToken);

        if (payload.expires) {
          lsStoreExpires(payload.expires);
        }
      }
    });
    return {
      callAuthApiPromise: callAuthApiPromise,
      callAuthApiObservable: callAuthApiObservable
    };
  } // Run should be called after applied middleware in redux


  authMiddleware.run = run;
  return authMiddleware;
}

var defaultMakeErrorFromException = function defaultMakeErrorFromException(ex) {
  return ex;
};

var noopStorageBackend = {
  getItem: function getItem() {
    return null;
  },
  setItem: function setItem() {},
  removeItem: function removeItem() {}
};

var makeAuth = function makeAuth(_ref) {
  var _marked =
  /*#__PURE__*/
  regeneratorRuntime.mark(ls),
      _marked2 =
  /*#__PURE__*/
  regeneratorRuntime.mark(lsGetAccessToken),
      _marked3 =
  /*#__PURE__*/
  regeneratorRuntime.mark(lsGetRefreshToken),
      _marked4 =
  /*#__PURE__*/
  regeneratorRuntime.mark(lsGetExpires),
      _marked5 =
  /*#__PURE__*/
  regeneratorRuntime.mark(lsStoreAccessToken),
      _marked6 =
  /*#__PURE__*/
  regeneratorRuntime.mark(lsStoreRefreshToken),
      _marked7 =
  /*#__PURE__*/
  regeneratorRuntime.mark(lsStoreExpires),
      _marked8 =
  /*#__PURE__*/
  regeneratorRuntime.mark(lsRemoveAccessToken),
      _marked9 =
  /*#__PURE__*/
  regeneratorRuntime.mark(lsRemoveRefreshToken),
      _marked10 =
  /*#__PURE__*/
  regeneratorRuntime.mark(lsRemoveExpires),
      _marked11 =
  /*#__PURE__*/
  regeneratorRuntime.mark(lsRemoveTokens),
      _marked12 =
  /*#__PURE__*/
  regeneratorRuntime.mark(getAccessToken),
      _marked13 =
  /*#__PURE__*/
  regeneratorRuntime.mark(getRefreshToken),
      _marked14 =
  /*#__PURE__*/
  regeneratorRuntime.mark(getTokenExpires),
      _marked15 =
  /*#__PURE__*/
  regeneratorRuntime.mark(apiCallWithRefresh),
      _marked16 =
  /*#__PURE__*/
  regeneratorRuntime.mark(authApiCall),
      _marked17 =
  /*#__PURE__*/
  regeneratorRuntime.mark(authenticateWithStorageToken),
      _marked18 =
  /*#__PURE__*/
  regeneratorRuntime.mark(watchLogin),
      _marked19 =
  /*#__PURE__*/
  regeneratorRuntime.mark(watchLogout),
      _marked20 =
  /*#__PURE__*/
  regeneratorRuntime.mark(refreshOnExpirationLoop),
      _marked21 =
  /*#__PURE__*/
  regeneratorRuntime.mark(authFlow);

  var meCall = _ref.meCall,
      loginCall = _ref.loginCall,
      refreshTokenCall = _ref.refreshTokenCall,
      storageBackend = _ref.storageBackend,
      _ref$reduxMountPoint = _ref.reduxMountPoint,
      reduxMountPoint = _ref$reduxMountPoint === void 0 ? 'auth' : _ref$reduxMountPoint,
      _ref$localStorageName = _ref.localStorageNamespace,
      localStorageNamespace = _ref$localStorageName === void 0 ? 'auth' : _ref$localStorageName,
      _ref$makeErrorFromExc = _ref.makeErrorFromException,
      makeErrorFromException = _ref$makeErrorFromExc === void 0 ? defaultMakeErrorFromException : _ref$makeErrorFromExc;
  var choosedStoageBackend;

  if (typeof storageBackend === 'undefined' || storageBackend === null) {
    if (typeof window !== 'undefined' && typeof window.localStorage !== 'undefined') {
      // If provided by environment use local storage
      choosedStoageBackend = window.localStorage;
    } else {
      // Use a noop storage backend (don't store anything)
      choosedStoageBackend = noopStorageBackend;
    }
  } else {
    // When given use provided storage backend
    choosedStoageBackend = storageBackend;
  } // redux saga helpers for Stroage Backend


  function ls(method) {
    var _len,
        args,
        _key,
        _args = arguments;

    return regeneratorRuntime.wrap(function ls$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;

            for (_len = _args.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = _args[_key];
            }

            _context.next = 4;
            return call.apply(void 0, [[choosedStoageBackend, method]].concat(args));

          case 4:
            return _context.abrupt("return", _context.sent);

          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            // Such shitty friend like mobile safari anonymous navigaton
            // kill trhows exception when trying to write on local storage
            // this prevent a runtime error
            console.error('Error while accessing local storage', _context.t0);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _marked, null, [[0, 7]]);
  } // Get from local storage


  function lsGetAccessToken() {
    var rawToken;
    return regeneratorRuntime.wrap(function lsGetAccessToken$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return ls('getItem', localStorageNamespace + ":accessToken");

          case 2:
            rawToken = _context2.sent;
            _context2.prev = 3;
            return _context2.abrupt("return", JSON.parse(rawToken));

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](3);
            return _context2.abrupt("return", null);

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2, null, [[3, 7]]);
  }

  function lsGetRefreshToken() {
    var rawToken;
    return regeneratorRuntime.wrap(function lsGetRefreshToken$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return ls('getItem', localStorageNamespace + ":refreshToken");

          case 2:
            rawToken = _context3.sent;
            _context3.prev = 3;
            return _context3.abrupt("return", JSON.parse(rawToken));

          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3["catch"](3);
            return _context3.abrupt("return", null);

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked3, null, [[3, 7]]);
  }

  function lsGetExpires() {
    var expiresAndTimestamp, timestamp, _expiresAndTimestamp$, relativeExpires, realtiveTimestamp;

    return regeneratorRuntime.wrap(function lsGetExpires$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return ls('getItem', localStorageNamespace + ":expires");

          case 2:
            expiresAndTimestamp = _context4.sent;

            if (!expiresAndTimestamp) {
              _context4.next = 7;
              break;
            }

            timestamp = parseInt(new Date().getTime() / 1000, 10);
            _expiresAndTimestamp$ = expiresAndTimestamp.split(','), relativeExpires = _expiresAndTimestamp$[0], realtiveTimestamp = _expiresAndTimestamp$[1];
            return _context4.abrupt("return", parseInt(relativeExpires, 10) - (timestamp - parseInt(realtiveTimestamp, 10)));

          case 7:
            return _context4.abrupt("return", null);

          case 8:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked4);
  } // Store to local storage


  function lsStoreAccessToken(token) {
    var jsonToken;
    return regeneratorRuntime.wrap(function lsStoreAccessToken$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            jsonToken = typeof token === 'undefined' ? 'null' : JSON.stringify(token);
            _context5.next = 3;
            return ls('setItem', localStorageNamespace + ":accessToken", jsonToken);

          case 3:
          case "end":
            return _context5.stop();
        }
      }
    }, _marked5);
  }

  function lsStoreRefreshToken(token) {
    var jsonToken;
    return regeneratorRuntime.wrap(function lsStoreRefreshToken$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            jsonToken = typeof token === 'undefined' ? 'null' : JSON.stringify(token);
            _context6.next = 3;
            return ls('setItem', localStorageNamespace + ":refreshToken", jsonToken);

          case 3:
          case "end":
            return _context6.stop();
        }
      }
    }, _marked6);
  }

  function lsStoreExpires(expires) {
    var timestamp;
    return regeneratorRuntime.wrap(function lsStoreExpires$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            // Store along seconds timestamp...
            timestamp = parseInt(new Date().getTime() / 1000, 10);
            _context7.next = 3;
            return ls('setItem', localStorageNamespace + ":expires", expires + "," + timestamp);

          case 3:
          case "end":
            return _context7.stop();
        }
      }
    }, _marked7);
  } // Remove from local storage


  function lsRemoveAccessToken(token) {
    return regeneratorRuntime.wrap(function lsRemoveAccessToken$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return ls('removeItem', localStorageNamespace + ":accessToken");

          case 2:
          case "end":
            return _context8.stop();
        }
      }
    }, _marked8);
  }

  function lsRemoveRefreshToken(token) {
    return regeneratorRuntime.wrap(function lsRemoveRefreshToken$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return ls('removeItem', localStorageNamespace + ":refreshToken");

          case 2:
          case "end":
            return _context9.stop();
        }
      }
    }, _marked9);
  }

  function lsRemoveExpires(token) {
    return regeneratorRuntime.wrap(function lsRemoveExpires$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return ls('removeItem', localStorageNamespace + ":expires");

          case 2:
          case "end":
            return _context10.stop();
        }
      }
    }, _marked10);
  }

  function lsRemoveTokens() {
    return regeneratorRuntime.wrap(function lsRemoveTokens$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return lsRemoveAccessToken();

          case 2:
            _context11.next = 4;
            return lsRemoveRefreshToken();

          case 4:
            _context11.next = 6;
            return lsRemoveExpires();

          case 6:
          case "end":
            return _context11.stop();
        }
      }
    }, _marked11);
  } // redux saga helpers for getting tokens from redux store


  var selectAuth = function selectAuth(state) {
    return state[reduxMountPoint];
  };

  function getAccessToken() {
    return regeneratorRuntime.wrap(function getAccessToken$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            _context12.next = 2;
            return select(function (state) {
              return selectAuth(state).accessToken;
            });

          case 2:
            return _context12.abrupt("return", _context12.sent);

          case 3:
          case "end":
            return _context12.stop();
        }
      }
    }, _marked12);
  }

  function getRefreshToken() {
    return regeneratorRuntime.wrap(function getRefreshToken$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            _context13.next = 2;
            return select(function (state) {
              return selectAuth(state).refreshToken;
            });

          case 2:
            return _context13.abrupt("return", _context13.sent);

          case 3:
          case "end":
            return _context13.stop();
        }
      }
    }, _marked13);
  }

  function getTokenExpires() {
    return regeneratorRuntime.wrap(function getTokenExpires$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            _context14.next = 2;
            return select(function (state) {
              return selectAuth(state).expires;
            });

          case 2:
            return _context14.abrupt("return", _context14.sent);

          case 3:
          case "end":
            return _context14.stop();
        }
      }
    }, _marked14);
  }

  function apiCallWithRefresh(accessToken, refreshToken, apiFn) {
    var _len2,
        args,
        _key2,
        result,
        refresh,
        _result,
        _args15 = arguments;

    return regeneratorRuntime.wrap(function apiCallWithRefresh$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            for (_len2 = _args15.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
              args[_key2 - 3] = _args15[_key2];
            }

            _context15.prev = 1;
            _context15.next = 4;
            return call.apply(void 0, [apiFn(accessToken)].concat(args));

          case 4:
            result = _context15.sent;
            return _context15.abrupt("return", [result, {
              accessToken: accessToken,
              refreshToken: refreshToken,
              refreshed: false
            }]);

          case 8:
            _context15.prev = 8;
            _context15.t0 = _context15["catch"](1);

            if (!(typeof refreshTokenCall !== 'function')) {
              _context15.next = 12;
              break;
            }

            throw _context15.t0;

          case 12:
            if (!(_context15.t0.status === 401)) {
              _context15.next = 30;
              break;
            }

            _context15.next = 15;
            return put(tokenRefreshing());

          case 15:
            _context15.prev = 15;
            _context15.next = 18;
            return call(refreshTokenCall, refreshToken);

          case 18:
            refresh = _context15.sent;
            _context15.next = 24;
            break;

          case 21:
            _context15.prev = 21;
            _context15.t1 = _context15["catch"](15);
            throw _context15.t0;

          case 24:
            _context15.next = 26;
            return call.apply(void 0, [apiFn(refresh.access_token)].concat(args));

          case 26:
            _result = _context15.sent;
            return _context15.abrupt("return", [_result, {
              accessToken: refresh.access_token,
              refreshToken: refresh.refresh_token,
              expires: refresh.expires,
              refreshed: true
            }]);

          case 30:
            throw _context15.t0;

          case 31:
          case "end":
            return _context15.stop();
        }
      }
    }, _marked15, null, [[1, 8], [15, 21]]);
  } // make an auth api call (curry given or taken from store accessToken)


  function authApiCall(apiFn) {
    var accessToken,
        refreshToken,
        _len3,
        args,
        _key3,
        _ref2,
        result,
        _refresh,
        _args16 = arguments;

    return regeneratorRuntime.wrap(function authApiCall$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            _context16.next = 2;
            return getAccessToken();

          case 2:
            accessToken = _context16.sent;
            _context16.next = 5;
            return getRefreshToken();

          case 5:
            refreshToken = _context16.sent;
            _context16.prev = 6;

            for (_len3 = _args16.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              args[_key3 - 1] = _args16[_key3];
            }

            _context16.next = 10;
            return apiCallWithRefresh.apply(void 0, [accessToken, refreshToken, apiFn].concat(args));

          case 10:
            _ref2 = _context16.sent;
            result = _ref2[0];
            _refresh = _ref2[1];

            if (!(_refresh && _refresh.refreshed)) {
              _context16.next = 23;
              break;
            }

            _context16.next = 16;
            return lsStoreAccessToken(_refresh.accessToken);

          case 16:
            _context16.next = 18;
            return lsStoreRefreshToken(_refresh.refreshToken);

          case 18:
            if (!_refresh.expires) {
              _context16.next = 21;
              break;
            }

            _context16.next = 21;
            return lsStoreExpires(_refresh.expires);

          case 21:
            _context16.next = 23;
            return put(tokenRefreshed(_refresh));

          case 23:
            return _context16.abrupt("return", result);

          case 26:
            _context16.prev = 26;
            _context16.t0 = _context16["catch"](6);

            if (!(_context16.t0.status === 401)) {
              _context16.next = 31;
              break;
            }

            _context16.next = 31;
            return put(logout());

          case 31:
            if (!(_context16.t0.status === 403)) {
              _context16.next = 34;
              break;
            }

            _context16.next = 34;
            return put(logout({
              fromPermission: true
            }));

          case 34:
            throw _context16.t0;

          case 35:
          case "end":
            return _context16.stop();
        }
      }
    }, _marked16, null, [[6, 26]]);
  }

  function authenticateWithStorageToken() {
    var lsAccessToken, lsRefreshToken, me, _ref3, user, _ref3$, accessToken, refreshToken, refreshExpires, refreshed, expires;

    return regeneratorRuntime.wrap(function authenticateWithStorageToken$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            _context17.next = 2;
            return put({
              type: BOOTSTRAP_AUTH_START
            });

          case 2:
            _context17.next = 4;
            return lsGetAccessToken();

          case 4:
            lsAccessToken = _context17.sent;
            _context17.next = 7;
            return lsGetRefreshToken();

          case 7:
            lsRefreshToken = _context17.sent;

            if (!lsAccessToken) {
              _context17.next = 46;
              break;
            }

            _context17.next = 11;
            return put({
              type: AUTH_WITH_TOKEN_LOADING
            });

          case 11:
            _context17.prev = 11;

            // Curried me
            me = function me(token) {
              return function () {
                return meCall(token);
              };
            };

            _context17.next = 15;
            return apiCallWithRefresh(lsAccessToken, lsRefreshToken, me);

          case 15:
            _ref3 = _context17.sent;
            user = _ref3[0];
            _ref3$ = _ref3[1];
            accessToken = _ref3$.accessToken;
            refreshToken = _ref3$.refreshToken;
            refreshExpires = _ref3$.expires;
            refreshed = _ref3$.refreshed;

            if (!refreshed) {
              _context17.next = 33;
              break;
            }

            expires = refreshExpires;
            _context17.next = 26;
            return lsStoreAccessToken(accessToken);

          case 26:
            _context17.next = 28;
            return lsStoreRefreshToken(refreshToken);

          case 28:
            if (!expires) {
              _context17.next = 31;
              break;
            }

            _context17.next = 31;
            return lsStoreExpires(expires);

          case 31:
            _context17.next = 36;
            break;

          case 33:
            _context17.next = 35;
            return lsGetExpires();

          case 35:
            expires = _context17.sent;

          case 36:
            _context17.next = 38;
            return put({
              type: AUTH_WITH_TOKEN_SUCCESS,
              payload: {
                user: user,
                accessToken: accessToken,
                refreshToken: refreshToken,
                expires: expires
              }
            });

          case 38:
            _context17.next = 46;
            break;

          case 40:
            _context17.prev = 40;
            _context17.t0 = _context17["catch"](11);
            _context17.next = 44;
            return put({
              type: AUTH_WITH_TOKEN_FAILURE,
              error: makeErrorFromException(_context17.t0)
            });

          case 44:
            _context17.next = 46;
            return lsRemoveTokens();

          case 46:
            _context17.next = 48;
            return put({
              type: BOOTSTRAP_AUTH_END
            });

          case 48:
          case "end":
            return _context17.stop();
        }
      }
    }, _marked17, null, [[11, 40]]);
  } // Watch login action and then try to authenticate user with given
  // credentials, if ok store tokens


  function watchLogin() {
    var _ref4, payload, credentials, loginResponse, access_token, refresh_token, _loginResponse$expire, _expires, user;

    return regeneratorRuntime.wrap(function watchLogin$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            _context18.next = 2;
            return take$1(LOGIN);

          case 2:
            _ref4 = _context18.sent;
            payload = _ref4.payload;
            credentials = payload.credentials;
            _context18.next = 7;
            return put({
              type: LOGIN_LOADING
            });

          case 7:
            _context18.prev = 7;
            _context18.next = 10;
            return call(loginCall, credentials);

          case 10:
            loginResponse = _context18.sent;
            access_token = loginResponse.access_token, refresh_token = loginResponse.refresh_token, _loginResponse$expire = loginResponse.expires, _expires = _loginResponse$expire === void 0 ? null : _loginResponse$expire; // Using access token to get user info
            // ... passing additional param loginResponse over access_token
            // to get for example the user info from login response rather than
            // the me api endpoint

            _context18.next = 14;
            return call(meCall, access_token, loginResponse);

          case 14:
            user = _context18.sent;
            _context18.next = 17;
            return lsStoreAccessToken(access_token);

          case 17:
            _context18.next = 19;
            return lsStoreRefreshToken(refresh_token);

          case 19:
            if (!_expires) {
              _context18.next = 22;
              break;
            }

            _context18.next = 22;
            return lsStoreExpires(_expires);

          case 22:
            _context18.next = 24;
            return put({
              type: LOGIN_SUCCESS,
              payload: {
                user: user,
                expires: _expires,
                accessToken: access_token,
                refreshToken: refresh_token
              }
            });

          case 24:
            _context18.next = 30;
            break;

          case 26:
            _context18.prev = 26;
            _context18.t0 = _context18["catch"](7);
            _context18.next = 30;
            return put({
              type: LOGIN_FAILURE,
              error: makeErrorFromException(_context18.t0)
            });

          case 30:
          case "end":
            return _context18.stop();
        }
      }
    }, _marked18, null, [[7, 26]]);
  } // Wait logout action and then remove tokens from storage


  function watchLogout() {
    return regeneratorRuntime.wrap(function watchLogout$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            _context19.next = 2;
            return take$1(LOGOUT);

          case 2:
            _context19.next = 4;
            return lsRemoveTokens();

          case 4:
          case "end":
            return _context19.stop();
        }
      }
    }, _marked19);
  } // Wait expiration and try to rehresh token!


  function refreshOnExpirationLoop() {
    var _expires2, refreshToken, _refresh2;

    return regeneratorRuntime.wrap(function refreshOnExpirationLoop$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:

            _context20.next = 3;
            return getTokenExpires();

          case 3:
            _expires2 = _context20.sent;
            _context20.next = 6;
            return delay(1000 * _expires2);

          case 6:
            _context20.next = 8;
            return getRefreshToken();

          case 8:
            refreshToken = _context20.sent;
            _context20.next = 11;
            return put(tokenRefreshing());

          case 11:
            _context20.prev = 11;
            _context20.next = 14;
            return call(refreshTokenCall, refreshToken);

          case 14:
            _refresh2 = _context20.sent;
            _context20.next = 17;
            return lsStoreAccessToken(_refresh2.access_token);

          case 17:
            _context20.next = 19;
            return lsStoreRefreshToken(_refresh2.refresh_token);

          case 19:
            _context20.next = 21;
            return lsStoreExpires(_refresh2.expires);

          case 21:
            _context20.next = 23;
            return put(tokenRefreshed({
              expires: _refresh2.expires,
              accessToken: _refresh2.access_token,
              refreshToken: _refresh2.refresh_token
            }));

          case 23:
            _context20.next = 29;
            break;

          case 25:
            _context20.prev = 25;
            _context20.t0 = _context20["catch"](11);
            _context20.next = 29;
            return put(logout());

          case 29:
            _context20.next = 0;
            break;

          case 31:
          case "end":
            return _context20.stop();
        }
      }
    }, _marked20, null, [[11, 25]]);
  } // le Auth flow saga


  function authFlow() {
    var refreshTokenTask, _refreshTokenTask;

    return regeneratorRuntime.wrap(function authFlow$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            _context21.next = 2;
            return authenticateWithStorageToken();

          case 2:
            _context21.next = 4;
            return getAccessToken();

          case 4:
            if (!_context21.sent) {
              _context21.next = 16;
              break;
            }

            _context21.next = 7;
            return getTokenExpires();

          case 7:
            if (!_context21.sent) {
              _context21.next = 11;
              break;
            }

            _context21.next = 10;
            return fork(refreshOnExpirationLoop);

          case 10:
            refreshTokenTask = _context21.sent;

          case 11:
            _context21.next = 13;
            return watchLogout();

          case 13:
            if (!refreshTokenTask) {
              _context21.next = 16;
              break;
            }

            _context21.next = 16;
            return cancel(refreshTokenTask);

          case 16:

            _context21.next = 19;
            return watchLogin();

          case 19:
            _context21.next = 21;
            return getAccessToken();

          case 21:
            if (!_context21.sent) {
              _context21.next = 34;
              break;
            }

            _refreshTokenTask = void 0;
            _context21.next = 25;
            return getTokenExpires();

          case 25:
            if (!_context21.sent) {
              _context21.next = 29;
              break;
            }

            _context21.next = 28;
            return fork(refreshOnExpirationLoop);

          case 28:
            _refreshTokenTask = _context21.sent;

          case 29:
            _context21.next = 31;
            return watchLogout();

          case 31:
            if (!_refreshTokenTask) {
              _context21.next = 34;
              break;
            }

            _context21.next = 34;
            return cancel(_refreshTokenTask);

          case 34:
            _context21.next = 16;
            break;

          case 36:
          case "end":
            return _context21.stop();
        }
      }
    }, _marked21);
  }

  function makeAuthMiddleware$1() {
    return makeAuthMiddleware({
      meCall: meCall,
      loginCall: loginCall,
      refreshTokenCall: refreshTokenCall,
      storageBackend: storageBackend,
      reduxMountPoint: reduxMountPoint,
      localStorageNamespace: localStorageNamespace,
      makeErrorFromException: makeErrorFromException
    });
  }

  return {
    authFlow: authFlow,
    authApiCall: authApiCall,
    makeAuthMiddleware: makeAuthMiddleware$1
  };
};

var isLoginLoading = function isLoginLoading(state) {
  return state.auth.loginLoading;
};
var getLoginError = function getLoginError(state) {
  return state.auth.loginError;
};
var getAuthUser = function getAuthUser(state) {
  return state.auth.user;
};
var getAuthAccessToken = function getAuthAccessToken(state) {
  return state.auth.accessToken;
};
var getAuthRefreshToken = function getAuthRefreshToken(state) {
  return state.auth.refreshToken;
};
var getAuthTokenExpires = function getAuthTokenExpires(state) {
  return state.auth.expires;
};

function withAuthLogin(c) {
  if (c === void 0) {
    c = {};
  }

  var config = _extends({
    credentials: ['email', 'password'],
    "native": false,
    shouldClearErrorOnChange: true
  }, c);

  var defaultCredentials = config.credentials.reduce(function (r, c) {
    var _extends2;

    return _extends({}, r, (_extends2 = {}, _extends2[c] = '', _extends2));
  }, {});
  return function wrapWithLogin(WrappedComponent) {
    var BaseLogin =
    /*#__PURE__*/
    function (_PureComponent) {
      _inheritsLoose(BaseLogin, _PureComponent);

      function BaseLogin() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _PureComponent.call.apply(_PureComponent, [this].concat(args)) || this;

        _defineProperty(_assertThisInitialized(_this), "state", {
          credentials: defaultCredentials
        });

        _defineProperty(_assertThisInitialized(_this), "makeOnCredentialChange", function (field) {
          return function (e) {
            var value = e;

            if (e && typeof window !== 'undefined' && typeof window.Element !== 'undefined' && e.target instanceof window.Element) {
              value = e.target.value;
            }

            if (_this.props.error && config.shouldClearErrorOnChange) {
              _this.props.clearLoginError();
            }

            _this.setState(function (prevState) {
              var _extends3;

              return {
                credentials: _extends({}, prevState.credentials, (_extends3 = {}, _extends3[field] = value, _extends3))
              };
            });
          };
        });

        _defineProperty(_assertThisInitialized(_this), "handleLoginSubmit", function (e) {
          if (e && typeof e === 'object' && typeof e.preventDefault === 'function') {
            e.preventDefault();
          }

          var credentials = _this.state.credentials;
          var isValid = Object.keys(credentials).every(function (c) {
            return credentials[c].trim() !== '';
          });

          if (isValid) {
            _this.props.login(credentials);
          }
        });

        _defineProperty(_assertThisInitialized(_this), "makeCredentialsProp", function () {
          return config.credentials.reduce(function (r, c) {
            var _c, _extends4;

            var onChangeKey = config["native"] ? 'onChangeText' : 'onChange';
            return _extends({}, r, (_extends4 = {}, _extends4[c] = (_c = {
              value: _this.state.credentials[c]
            }, _c[onChangeKey] = _this.makeOnCredentialChange(c), _c), _extends4));
          }, {});
        });

        return _this;
      }

      var _proto = BaseLogin.prototype;

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.props.clearLoginError();
      };

      _proto.render = function render() {
        return createElement(WrappedComponent, _extends({}, this.props, {
          credentials: this.makeCredentialsProp(),
          handleSubmit: this.handleLoginSubmit
        }));
      };

      return BaseLogin;
    }(PureComponent);

    var mapStateToProps = function mapStateToProps(state) {
      return {
        error: getLoginError(state),
        loading: isLoginLoading(state)
      };
    };

    var Login = connect(mapStateToProps, {
      clearLoginError: clearLoginError,
      login: login
    })(BaseLogin);
    return hoistStatics(Login, WrappedComponent);
  };
}

/**
 * Ensure user logged otherwise redirect them to login
 *
 */

var AuthRoute = function AuthRoute(_ref) {
  var component = _ref.component,
      _ref$spinner = _ref.spinner,
      spinner = _ref$spinner === void 0 ? null : _ref$spinner,
      _ref$redirectTo = _ref.redirectTo,
      redirectTo = _ref$redirectTo === void 0 ? '/login' : _ref$redirectTo,
      _ref$rememberReferrer = _ref.rememberReferrer,
      rememberReferrer = _ref$rememberReferrer === void 0 ? true : _ref$rememberReferrer,
      redirectTest = _ref.redirectTest,
      auth = _ref.auth,
      rest = _objectWithoutPropertiesLoose(_ref, ["component", "spinner", "redirectTo", "rememberReferrer", "redirectTest", "auth"]);

  return React.createElement(Route, _extends({}, rest, {
    render: function render(props) {
      if (auth.authenticatingWithToken || auth.loginLoading) {
        // Show nothing or a cool loading spinner
        return spinner ? React.createElement(spinner) : null;
      } // User authenticated


      if (auth.user) {
        // Use test function when provided
        if (typeof redirectTest === 'function') {
          var userRedirectTo = redirectTest(auth.user);

          if (userRedirectTo) {
            return React.createElement(Redirect, {
              to: userRedirectTo
            });
          }
        } // Render normal component


        return React.createElement(component, props);
      } // User not authenticated, redirect to login


      var to = typeof redirectTo === 'string' ? {
        pathname: redirectTo
      } : redirectTo;
      return React.createElement(Redirect, {
        to: _extends({}, to, {
          state: _extends({}, to.state, {
            referrer: rememberReferrer && !auth.logoutFromPermission ? props.location : undefined
          })
        })
      });
    }
  }));
};

var AuthRoute$1 = connect(function (_ref2) {
  var auth = _ref2.auth;
  return {
    auth: auth
  };
})(AuthRoute);

/**
 * Wait for auth loading before rendering route component
 * (needed for first time local storage auth...)
 *
 */

var MaybeAuthRoute = function MaybeAuthRoute(_ref) {
  var component = _ref.component,
      _ref$spinner = _ref.spinner,
      spinner = _ref$spinner === void 0 ? null : _ref$spinner,
      auth = _ref.auth,
      rest = _objectWithoutPropertiesLoose(_ref, ["component", "spinner", "auth"]);

  return React.createElement(Route, _extends({}, rest, {
    render: function render(props) {
      if (auth.authenticatingWithToken || auth.loginLoading) {
        // Show nothing or a cool loading spinner
        return spinner ? React.createElement(spinner) : null;
      } // Always render route component


      return React.createElement(component, props);
    }
  }));
};

var MaybeAuthRoute$1 = connect(function (_ref2) {
  var auth = _ref2.auth;
  return {
    auth: auth
  };
})(MaybeAuthRoute);

/**
 * Redirect to home when user logged in
 *
 */

var GuestRoute = function GuestRoute(_ref) {
  var component = _ref.component,
      _ref$spinner = _ref.spinner,
      spinner = _ref$spinner === void 0 ? null : _ref$spinner,
      auth = _ref.auth,
      _ref$redirectTo = _ref.redirectTo,
      redirectTo = _ref$redirectTo === void 0 ? '/' : _ref$redirectTo,
      _ref$redirectToReferr = _ref.redirectToReferrer,
      redirectToReferrer = _ref$redirectToReferr === void 0 ? true : _ref$redirectToReferr,
      rest = _objectWithoutPropertiesLoose(_ref, ["component", "spinner", "auth", "redirectTo", "redirectToReferrer"]);

  return React.createElement(Route, _extends({}, rest, {
    render: function render(props) {
      if (auth.user) {
        // Redirect to referrer location
        var location = props.location;

        if (redirectToReferrer && location.state && location.state.referrer) {
          return React.createElement(Redirect, {
            to: typeof redirectTo === 'string' ? location.state.referrer : // If redirectTo is an object merged the state
            // of location to redirect....
            _extends({}, location.state.referrer, {
              state: _extends({}, redirectTo.state, location.state.referrer.state)
            })
          });
        }

        return React.createElement(Redirect, {
          to: redirectTo
        });
      }

      if (auth.authenticatingWithToken) {
        return spinner ? React.createElement(spinner) : null;
      }

      return React.createElement(component, props);
    }
  }));
};

var GuestRoute$1 = connect(function (_ref2) {
  var auth = _ref2.auth;
  return {
    auth: auth
  };
})(GuestRoute);

var RECOVER_PASSWORD_UNLOAD = NS + "RECOVER_PASSWORD_UNLOAD";
var RECOVER_PASSWORD = NS + "RECOVER_PASSWORD";
var RECOVER_PASSWORD_LOADING = NS + "RECOVER_PASSWORD_LOADING";
var RECOVER_PASSWORD_SUCCESS = NS + "RECOVER_PASSWORD_SUCCESS";
var RECOVER_PASSWORD_FAILURE = NS + "RECOVER_PASSWORD_FAILURE";
var recoverPassword = function recoverPassword() {
  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return {
    type: RECOVER_PASSWORD,
    payload: {
      params: params
    }
  };
};
var unloadPasswordRecover = function unloadPasswordRecover() {
  return {
    type: RECOVER_PASSWORD_UNLOAD
  };
};

var RESET_PASSWORD_UNLOAD = NS + "RESET_PASSWORD_UNLOAD";
var unloadPasswordReset = function unloadPasswordReset() {
  return {
    type: RESET_PASSWORD_UNLOAD
  };
};
var RESET_PASSWORD_CHECK_TOKEN = NS + "RESET_PASSWORD_CHECK_TOKEN";
var RESET_PASSWORD_CHECK_TOKEN_LOADING = NS + "RESET_PASSWORD_CHECK_TOKEN_LOADING";
var RESET_PASSWORD_CHECK_TOKEN_SUCCESS = NS + "RESET_PASSWORD_CHECK_TOKEN_SUCCESS";
var RESET_PASSWORD_CHECK_TOKEN_FAILURE = NS + "RESET_PASSWORD_CHECK_TOKEN_FAILURE";
var checkResetPasswordToken = function checkResetPasswordToken(token) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }

  return {
    type: RESET_PASSWORD_CHECK_TOKEN,
    payload: {
      token: token,
      params: params
    }
  };
};
var RESET_PASSWORD_SENT = NS + "RESET_PASSWORD_SENT";
var RESET_PASSWORD_SENT_LOADING = NS + "RESET_PASSWORD_SENT_LOADING";
var RESET_PASSWORD_SENT_SUCCESS = NS + "RESET_PASSWORD_SENT_SUCCESS";
var RESET_PASSWORD_SENT_FAILURE = NS + "RESET_PASSWORD_SENT_FAILURE";
var resetPassword = function resetPassword(token, password) {
  for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    params[_key2 - 2] = arguments[_key2];
  }

  return {
    type: RESET_PASSWORD_SENT,
    payload: {
      token: token,
      password: password,
      params: params
    }
  };
};

var defaultState = {
  loading: false,
  // Link for recovered sent?
  recovered: false,
  error: null
};

var recover = function recover(prevState, _ref) {
  if (prevState === void 0) {
    prevState = defaultState;
  }

  var type = _ref.type,
      payload = _ref.payload,
      error = _ref.error;

  switch (type) {
    case RECOVER_PASSWORD_UNLOAD:
      return defaultState;

    case RECOVER_PASSWORD_LOADING:
      return _extends({}, prevState, {
        error: null,
        loading: true
      });

    case RECOVER_PASSWORD_SUCCESS:
      return _extends({}, prevState, {
        loading: false,
        recovered: true
      });

    case RECOVER_PASSWORD_FAILURE:
      return _extends({}, prevState, {
        error: error,
        loading: false
      });

    default:
      return prevState;
  }
};

var defaultCheckTokenState = {
  loading: false,
  error: null,
  tokenChecked: null
};

var checkToken = function checkToken(prevState, _ref) {
  if (prevState === void 0) {
    prevState = defaultCheckTokenState;
  }

  var type = _ref.type,
      payload = _ref.payload,
      error = _ref.error;

  switch (type) {
    case RESET_PASSWORD_UNLOAD:
      return defaultCheckTokenState;

    case RESET_PASSWORD_CHECK_TOKEN_LOADING:
      return _extends({}, prevState, {
        loading: true
      });

    case RESET_PASSWORD_CHECK_TOKEN_FAILURE:
      return _extends({}, prevState, {
        error: error,
        loading: false
      });

    case RESET_PASSWORD_CHECK_TOKEN_SUCCESS:
      return _extends({}, prevState, {
        // Sure that now token is valid
        tokenChecked: payload.token,
        loading: false
      });

    default:
      return prevState;
  }
};

var defaultSentResetState = {
  loading: false,
  error: null,
  resetted: false
};

var sentReset = function sentReset(prevState, _ref2) {
  if (prevState === void 0) {
    prevState = defaultSentResetState;
  }

  var type = _ref2.type,
      payload = _ref2.payload,
      error = _ref2.error;

  switch (type) {
    case RESET_PASSWORD_UNLOAD:
      return defaultSentResetState;

    case RESET_PASSWORD_SENT_LOADING:
      return _extends({}, prevState, {
        error: null,
        loading: true
      });

    case RESET_PASSWORD_SENT_FAILURE:
      return _extends({}, prevState, {
        error: error,
        loading: false
      });

    case RESET_PASSWORD_SENT_SUCCESS:
      return _extends({}, prevState, {
        resetted: true,
        loading: false
      });

    default:
      return prevState;
  }
};

var reset = combineReducers({
  check: checkToken,
  sent: sentReset
});

var makePasswordReducer = function makePasswordReducer(extraReducers) {
  if (extraReducers === void 0) {
    extraReducers = {};
  }

  return combineReducers({
    recover: withExtraReducer(recover, extraReducers.recover),
    reset: withExtraReducer(reset, extraReducers.reset)
  });
};

var _marked2 =
/*#__PURE__*/
regeneratorRuntime.mark(takeLatestAndCancel);

var arrayze = function arrayze(a) {
  return Array.isArray(a) ? a : [a];
};

var mergePatterns = function mergePatterns() {
  for (var _len = arguments.length, patterns = new Array(_len), _key = 0; _key < _len; _key++) {
    patterns[_key] = arguments[_key];
  }

  return patterns.reduce(function (finalPattern, pattern) {
    return [].concat(finalPattern, arrayze(pattern));
  }, []);
};

var matchPattern = function matchPattern(action, pattern) {
  return pattern === '*' || arrayze(pattern).indexOf(action.type) !== -1;
};
function takeLatestAndCancel(pattern, cancelPattern, saga) {
  var _len3,
      args,
      _key3,
      task,
      _args4 = arguments;

  return regeneratorRuntime.wrap(function takeLatestAndCancel$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          for (_len3 = _args4.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
            args[_key3 - 3] = _args4[_key3];
          }

          _context4.next = 3;
          return fork(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee2() {
            var lastTask, action;
            return regeneratorRuntime.wrap(function _callee2$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:

                    _context3.next = 3;
                    return take$1(mergePatterns(pattern, cancelPattern));

                  case 3:
                    action = _context3.sent;

                    if (!lastTask) {
                      _context3.next = 7;
                      break;
                    }

                    _context3.next = 7;
                    return cancel(lastTask);

                  case 7:
                    if (matchPattern(action, cancelPattern)) {
                      _context3.next = 11;
                      break;
                    }

                    _context3.next = 10;
                    return fork.apply(void 0, [saga].concat(args.concat(action)));

                  case 10:
                    lastTask = _context3.sent;

                  case 11:
                    _context3.next = 0;
                    break;

                  case 13:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee2);
          }));

        case 3:
          task = _context4.sent;
          return _context4.abrupt("return", task);

        case 5:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked2);
} // Difficult: Perfect Master

var makePassword = function makePassword(_ref) {
  var _marked =
  /*#__PURE__*/
  regeneratorRuntime.mark(handleRecover),
      _marked2 =
  /*#__PURE__*/
  regeneratorRuntime.mark(handleCheckResetPasswordToken),
      _marked3 =
  /*#__PURE__*/
  regeneratorRuntime.mark(handleResetPassword),
      _marked4 =
  /*#__PURE__*/
  regeneratorRuntime.mark(passwordFlow);

  var recoverPasswordCall = _ref.recoverPasswordCall,
      checkResetPasswordTokenCall = _ref.checkResetPasswordTokenCall,
      resetPasswordCall = _ref.resetPasswordCall;

  function handleRecover(_ref2) {
    var params;
    return regeneratorRuntime.wrap(function handleRecover$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            params = _ref2.payload.params;
            _context.next = 3;
            return put({
              type: RECOVER_PASSWORD_LOADING
            });

          case 3:
            _context.prev = 3;
            _context.next = 6;
            return call.apply(void 0, [recoverPasswordCall].concat(params));

          case 6:
            _context.next = 8;
            return put({
              type: RECOVER_PASSWORD_SUCCESS
            });

          case 8:
            _context.next = 14;
            break;

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](3);
            _context.next = 14;
            return put({
              type: RECOVER_PASSWORD_FAILURE,
              error: _context.t0
            });

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _marked, null, [[3, 10]]);
  }

  function handleCheckResetPasswordToken(_ref3) {
    var _ref3$payload, token, params;

    return regeneratorRuntime.wrap(function handleCheckResetPasswordToken$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref3$payload = _ref3.payload, token = _ref3$payload.token, params = _ref3$payload.params;
            _context2.next = 3;
            return put({
              type: RESET_PASSWORD_CHECK_TOKEN_LOADING
            });

          case 3:
            _context2.prev = 3;
            _context2.next = 6;
            return call.apply(void 0, [checkResetPasswordTokenCall, token].concat(params));

          case 6:
            _context2.next = 8;
            return put({
              type: RESET_PASSWORD_CHECK_TOKEN_SUCCESS,
              payload: {
                token: token
              }
            });

          case 8:
            _context2.next = 14;
            break;

          case 10:
            _context2.prev = 10;
            _context2.t0 = _context2["catch"](3);
            _context2.next = 14;
            return put({
              type: RESET_PASSWORD_CHECK_TOKEN_FAILURE,
              error: _context2.t0
            });

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2, null, [[3, 10]]);
  }

  function handleResetPassword(_ref4) {
    var _ref4$payload, token, password, params;

    return regeneratorRuntime.wrap(function handleResetPassword$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _ref4$payload = _ref4.payload, token = _ref4$payload.token, password = _ref4$payload.password, params = _ref4$payload.params;
            _context3.next = 3;
            return put({
              type: RESET_PASSWORD_SENT_LOADING
            });

          case 3:
            _context3.prev = 3;
            _context3.next = 6;
            return call.apply(void 0, [resetPasswordCall, token, password].concat(params));

          case 6:
            _context3.next = 8;
            return put({
              type: RESET_PASSWORD_SENT_SUCCESS
            });

          case 8:
            _context3.next = 14;
            break;

          case 10:
            _context3.prev = 10;
            _context3.t0 = _context3["catch"](3);
            _context3.next = 14;
            return put({
              type: RESET_PASSWORD_SENT_FAILURE,
              error: _context3.t0
            });

          case 14:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked3, null, [[3, 10]]);
  }

  function passwordFlow() {
    return regeneratorRuntime.wrap(function passwordFlow$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return fork(takeLatestAndCancel, RECOVER_PASSWORD, RECOVER_PASSWORD_UNLOAD, handleRecover);

          case 2:
            _context4.next = 4;
            return fork(takeLatestAndCancel, RESET_PASSWORD_CHECK_TOKEN, RESET_PASSWORD_UNLOAD, handleCheckResetPasswordToken);

          case 4:
            _context4.next = 6;
            return fork(takeLatestAndCancel, RESET_PASSWORD_SENT, RESET_PASSWORD_UNLOAD, handleResetPassword);

          case 6:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked4);
  }

  return passwordFlow;
};

// For future hooks of different password mount point
var selectPasswordState = function selectPasswordState(state) {
  return state.password;
};

var selectRecoverPasswordState = function selectRecoverPasswordState(state) {
  return selectPasswordState(state).recover;
};

var getPasswordRecoverEmail = function getPasswordRecoverEmail(state) {
  return selectRecoverPasswordState(state).email;
};
var isPasswordRecoverLoading = function isPasswordRecoverLoading(state) {
  return selectRecoverPasswordState(state).loading;
};
var getPasswordRecoverError = function getPasswordRecoverError(state) {
  return selectRecoverPasswordState(state).error;
};
var isPasswordRecovered = function isPasswordRecovered(state) {
  return selectRecoverPasswordState(state).recovered;
};

var selectResetPasswordState = function selectResetPasswordState(state) {
  return selectPasswordState(state).reset;
};

var isCheckingResetPasswordToken = function isCheckingResetPasswordToken(state) {
  return selectResetPasswordState(state).check.loading;
};
var getCheckResetPasswordTokenError = function getCheckResetPasswordTokenError(state) {
  return selectResetPasswordState(state).check.error;
};
var getResetPasswordToken = function getResetPasswordToken(state) {
  return selectResetPasswordState(state).check.tokenChecked;
};
var isPasswordResetted = function isPasswordResetted(state) {
  return selectResetPasswordState(state).sent.resetted;
};
var getResetPasswordError = function getResetPasswordError(state) {
  return selectResetPasswordState(state).sent.error;
};
var isResettingPassword = function isResettingPassword(state) {
  return selectResetPasswordState(state).sent.loading;
};

var isEmailValidMem = defaultMemoize(isEmailValid);
function withPasswordRecover() {
  return function wrapWithRecover(WrappedComponent) {
    var BaseRecover =
    /*#__PURE__*/
    function (_PureComponent) {
      _inheritsLoose(BaseRecover, _PureComponent);

      function BaseRecover() {
        var _this;

        for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
          _args[_key] = arguments[_key];
        }

        _this = _PureComponent.call.apply(_PureComponent, [this].concat(_args)) || this;

        _defineProperty(_assertThisInitialized(_this), "state", {
          recoverEmail: ''
        });

        _defineProperty(_assertThisInitialized(_this), "onRecoverEmailChange", function (e) {
          _this.setState({
            recoverEmail: e.target.value
          });
        });

        _defineProperty(_assertThisInitialized(_this), "onSubmitRecoverPassword", function (e) {
          var _this$props;

          if (e && typeof e.preventDefault === 'function') {
            e.preventDefault();
          }

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          (_this$props = _this.props).recoverPassword.apply(_this$props, [_this.state.recoverEmail].concat(args));
        });

        return _this;
      }

      var _proto = BaseRecover.prototype;

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.props.unloadPasswordRecover();
      };

      _proto.render = function render() {
        return createElement(WrappedComponent, _extends({}, this.props, {
          recoverEmail: this.state.recoverEmail,
          onRecoverEmailChange: this.onRecoverEmailChange,
          isRecoverEmailValid: isEmailValidMem(this.state.recoverEmail),
          onSubmitRecoverPassword: this.onSubmitRecoverPassword
        }));
      };

      return BaseRecover;
    }(PureComponent);

    var mapStateToProps = function mapStateToProps(state) {
      return {
        recoverError: getPasswordRecoverError(state),
        recoverLoading: isPasswordRecoverLoading(state),
        recovered: isPasswordRecovered(state)
      };
    };

    var Recover = connect(mapStateToProps, {
      recoverPassword: recoverPassword,
      unloadPasswordRecover: unloadPasswordRecover
    })(BaseRecover);
    return hoistStatics(Recover, WrappedComponent);
  };
}

function withPasswordReset(c) {
  if (c === void 0) {
    c = {};
  }

  var config = _extends({
    passwordValidator: function passwordValidator(password) {
      return password.trim() !== '';
    },
    tokenFromProps: function tokenFromProps(_ref) {
      var token = _ref.token;
      return token;
    },
    shouldCheckToken: true
  }, c); // This avoid to re-run complex fucking regex for the same password...


  var isPasswordValid = defaultMemoize(config.passwordValidator);
  return function wrapWithReset(WrappedComponent) {
    var BaseReset =
    /*#__PURE__*/
    function (_PureComponent) {
      _inheritsLoose(BaseReset, _PureComponent);

      function BaseReset() {
        var _this;

        for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
          _args[_key] = arguments[_key];
        }

        _this = _PureComponent.call.apply(_PureComponent, [this].concat(_args)) || this;

        _defineProperty(_assertThisInitialized(_this), "state", {
          password: '',
          passwordRepeat: ''
        });

        _defineProperty(_assertThisInitialized(_this), "getResetToken", function () {
          return config.tokenFromProps(_this.props);
        });

        _defineProperty(_assertThisInitialized(_this), "onSubmitResetPassword", function (e) {
          var _this$props;

          if (e && typeof e.preventDefault === 'function') {
            e.preventDefault();
          }

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          (_this$props = _this.props).resetPassword.apply(_this$props, [_this.getResetToken(), _this.state.password].concat(args));
        });

        _defineProperty(_assertThisInitialized(_this), "makeOnFieldChange", function (field) {
          return function (e) {
            var value = e;

            if (e && e.target instanceof Element) {
              value = e.target.value;
            }

            _this.setState(function (prevState) {
              var _ref2;

              return _ref2 = {}, _ref2[field] = value, _ref2;
            });
          };
        });

        _defineProperty(_assertThisInitialized(_this), "makeFieldsProp", function () {
          return {
            password: {
              input: {
                value: _this.state.password,
                onChange: _this.makeOnFieldChange('password')
              },
              empty: _this.state.password.trim() === '',
              valid: isPasswordValid(_this.state.password)
            },
            passwordRepeat: {
              input: {
                value: _this.state.passwordRepeat,
                onChange: _this.makeOnFieldChange('passwordRepeat')
              },
              empty: _this.state.passwordRepeat.trim() === '',
              equal: _this.state.password === _this.state.passwordRepeat
            }
          };
        });

        _defineProperty(_assertThisInitialized(_this), "isValid", function () {
          return _this.state.password.trim() !== '' && _this.state.passwordRepeat.trim() !== '' && isPasswordValid(_this.state.password) && _this.state.password === _this.state.passwordRepeat;
        });

        return _this;
      }

      var _proto = BaseReset.prototype;

      _proto.componentDidMount = function componentDidMount() {
        if (config.shouldCheckToken) {
          this.props.checkResetPasswordToken(this.getResetToken());
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.props.unloadPasswordReset();
      };

      _proto.render = function render() {
        return createElement(WrappedComponent, _extends({}, this.props, {
          handleSubmit: this.onSubmitResetPassword,
          fields: this.makeFieldsProp(),
          isValid: this.isValid(),
          resetToken: this.getResetToken()
        }));
      };

      return BaseReset;
    }(PureComponent);

    var mapStateToProps = function mapStateToProps(state) {
      return {
        isCheckingResetToken: isCheckingResetPasswordToken(state),
        checkTokenError: getCheckResetPasswordTokenError(state),
        resetPasswordError: getResetPasswordError(state),
        validResetToken: getResetPasswordToken(state),
        passwordResetted: isPasswordResetted(state),
        isResettingPassword: isResettingPassword(state)
      };
    };

    var Reset = connect(mapStateToProps, {
      checkResetPasswordToken: checkResetPasswordToken,
      unloadPasswordReset: unloadPasswordReset,
      resetPassword: resetPassword
    })(BaseReset);
    return hoistStatics(Reset, WrappedComponent);
  };
}

export { AUTH_WITH_TOKEN_FAILURE, AUTH_WITH_TOKEN_LOADING, AUTH_WITH_TOKEN_SUCCESS, AuthRoute$1 as AuthRoute, BOOTSTRAP_AUTH_END, BOOTSTRAP_AUTH_START, CLEAR_LOGIN_ERROR, GuestRoute$1 as GuestRoute, LOGIN, LOGIN_FAILURE, LOGIN_LOADING, LOGIN_SUCCESS, LOGOUT, MaybeAuthRoute$1 as MaybeAuthRoute, PATCH_USER, RECOVER_PASSWORD, RECOVER_PASSWORD_FAILURE, RECOVER_PASSWORD_LOADING, RECOVER_PASSWORD_SUCCESS, RECOVER_PASSWORD_UNLOAD, RESET_PASSWORD_CHECK_TOKEN, RESET_PASSWORD_CHECK_TOKEN_FAILURE, RESET_PASSWORD_CHECK_TOKEN_LOADING, RESET_PASSWORD_CHECK_TOKEN_SUCCESS, RESET_PASSWORD_SENT, RESET_PASSWORD_SENT_FAILURE, RESET_PASSWORD_SENT_LOADING, RESET_PASSWORD_SENT_SUCCESS, RESET_PASSWORD_UNLOAD, TOKEN_REFRESHED, TOKEN_REFRESHING, UPDATE_USER, checkResetPasswordToken, clearLoginError, getAuthAccessToken, getAuthRefreshToken, getAuthTokenExpires, getAuthUser, getCheckResetPasswordTokenError, getLoginError, getPasswordRecoverEmail, getPasswordRecoverError, getResetPasswordError, getResetPasswordToken, isCheckingResetPasswordToken, isLoginLoading, isPasswordRecoverLoading, isPasswordRecovered, isPasswordResetted, isResettingPassword, login, logout, makeAuth as makeAuthFlow, makeAuthReducer, makePassword as makePasswordFlow, makePasswordReducer, patchUser, recoverPassword, resetPassword, tokenRefreshed, tokenRefreshing, unloadPasswordRecover, unloadPasswordReset, updateUser, withAuthLogin, withPasswordRecover, withPasswordReset };
