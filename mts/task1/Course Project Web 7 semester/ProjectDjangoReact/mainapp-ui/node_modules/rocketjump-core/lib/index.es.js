import _extends from '@babel/runtime/helpers/esm/extends';
import { get, mergeConfigs } from './utils.es.js';
import _construct from '@babel/runtime/helpers/esm/construct';
import { useState, useRef, useEffect, useMemo } from 'react';

// ~~ prince of saint felix ~~
var DefaultConfig = {
  shouldRun: true,
  metaOnMount: false,
  skipRunValue: false
};

var DeBp = /*#__PURE__*/function () {
  function DeBp(value, c) {
    if (c === void 0) {
      c = {};
    }

    var config = _extends({}, DefaultConfig, c);

    this._value = value;
    this._meta = config.meta;
    this._shouldRun = config.shouldRun;
    this._metaOnMount = config.metaOnMount;
    this._skipRunValue = config.skipRunValue;
  }

  var _proto = DeBp.prototype;

  _proto.getValue = function getValue() {
    return this._value;
  };

  _proto.metaOnMount = function metaOnMount() {
    return this._metaOnMount;
  };

  _proto.skipRunValue = function skipRunValue() {
    return this._skipRunValue;
  };

  _proto.shouldRun = function shouldRun() {
    return this._shouldRun;
  };

  _proto.withMeta = function withMeta(newMeta) {
    this._meta = _extends({}, this._meta, newMeta);
    return this;
  };

  _proto.getMeta = function getMeta(onMount) {
    if (onMount === void 0) {
      onMount = false;
    }

    // When we are on mount and meta are only 4 mount give undef
    if (!onMount && this._metaOnMount) {
      return undefined;
    }

    return this._meta;
  };

  return DeBp;
}();

var ifDep = function ifDep(a, cbTrue, cbFalse) {
  return a instanceof DeBp ? cbTrue() : cbFalse();
};
var RunDeBp = function RunDeBp(a) {
  return ifDep(a, function () {
    return new DeBp(a.getValue(), {
      shouldRun: true,
      meta: a.getMeta(),
      metaOnMount: a.metaOnMount(),
      skipRunValue: a.skipRunValue()
    });
  }, function () {
    return new DeBp(a, {
      shouldRun: true
    });
  });
};
var NotRunDeBp = function NotRunDeBp(a) {
  return ifDep(a, function () {
    return new DeBp(a.getValue(), {
      shouldRun: false,
      meta: a.getMeta(),
      metaOnMount: a.metaOnMount(),
      skipRunValue: a.skipRunValue()
    });
  }, function () {
    return new DeBp(a, {
      shouldRun: false
    });
  });
};
var WithMetaDeBp = function WithMetaDeBp(a, meta) {
  return ifDep(a, function () {
    return new DeBp(a.getValue(), {
      shouldRun: a.shouldRun(),
      meta: _extends({}, a.getMeta(), meta)
    });
  }, function () {
    return new DeBp(a, {
      shouldRun: true,
      meta: meta
    });
  });
};
var WithMetaOnMountDeBp = function WithMetaOnMountDeBp(meta) {
  return new DeBp(true, {
    shouldRun: true,
    meta: meta,
    metaOnMount: true,
    skipRunValue: true
  });
};
var WithAlwaysMeta = function WithAlwaysMeta(meta) {
  return new DeBp(true, {
    shouldRun: true,
    meta: meta,
    metaOnMount: false,
    skipRunValue: true
  });
};
var getDepValue = function getDepValue(a) {
  return ifDep(a, function () {
    return a.getValue();
  }, function () {
    return a;
  });
};
var getDepMeta = function getDepMeta(a, onMount) {
  return ifDep(a, function () {
    return a.getMeta(onMount);
  }, function () {
    return undefined;
  });
};
var shouldDepRun = function shouldDepRun(a) {
  return ifDep(a, function () {
    return a.shouldRun();
  }, function () {
    return true;
  });
};

// ~D3BpS~

var withMeta = function withMeta(a, meta) {
  return WithMetaDeBp(a, meta);
}; // Add meta only on mount

var withMetaOnMount = function withMetaOnMount(meta) {
  return WithMetaOnMountDeBp(meta);
}; // Add always meta

var withAlwaysMeta = function withAlwaysMeta(meta) {
  return WithAlwaysMeta(meta);
}; // Maybe run based on value

var maybe = function maybe(a) {
  return getDepValue(a) ? RunDeBp(a) : NotRunDeBp(a);
}; // Make all deps a maybe value!

var allMaybe = function allMaybe() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args.map(maybe);
}; // maybe if value is null

var maybeNull = function maybeNull(a) {
  return getDepValue(a) === null ? NotRunDeBp(a) : RunDeBp(a);
}; // Make all deps maybe null

var allMaybeNull = function allMaybeNull() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return args.map(maybeNull);
}; // Value + get object path or maybe

var maybeGet = function maybeGet(a, path) {
  var obj = getDepValue(a);

  if (obj) {
    return RunDeBp(get(obj, path));
  }

  return NotRunDeBp(a);
};

var allDeps = /*#__PURE__*/Object.freeze({
  __proto__: null,
  withMeta: withMeta,
  withMetaOnMount: withMetaOnMount,
  withAlwaysMeta: withAlwaysMeta,
  maybe: maybe,
  allMaybe: allMaybe,
  maybeNull: maybeNull,
  allMaybeNull: allMaybeNull,
  maybeGet: maybeGet
});

function getMetaFromDeps(argsWithDeps, oldValues, onMount) {
  if (oldValues === void 0) {
    oldValues = null;
  }

  if (oldValues === null) {
    var _useOnMount = onMount === undefined ? true // On mount (unless forced)
    : onMount; // All changes


    return argsWithDeps.reduce(function (meta, arg, i) {
      return _extends({}, meta, getDepMeta(argsWithDeps[i], _useOnMount));
    }, {});
  }

  var useOnMount = onMount === undefined ? false // Not on mount (unless forced)
  : onMount;
  var oldValuesLen = oldValues.length;
  return argsWithDeps.reduce(function (meta, arg, index) {
    if (index >= oldValuesLen || getDepValue(arg) !== oldValues[index]) {
      var depMeta = getDepMeta(arg, useOnMount);

      if (depMeta) {
        return _extends({}, meta, depMeta);
      }

      return meta;
    }

    return meta;
  }, {});
} // From run args to -> useEffect([...runValues])

function getRunValuesFromDeps(argsWithDeps) {
  return argsWithDeps.reduce(function (runValues, arg) {
    return ifDep(arg, function () {
      // Meta on mount are not handle a run value
      if (arg.skipRunValue()) {
        return runValues;
      }

      runValues.push(arg.getValue());
      return runValues;
    }, function () {
      runValues.push(arg);
      return runValues;
    });
  }, []);
} // Should run ma values?

function shouldRunDeps(argsWithDeps) {
  return !argsWithDeps.some(function (a) {
    return !shouldDepRun(a);
  });
}

// RJ Core interal types
// The curried config partial rj
// partialRj = rj(...)
var $TYPE_RJ_PARTIAL = Symbol('rj~partial'); // The extended exports type of export objects
// extended by recursion:
// partialRj(runConfig, extendedExport, impl)

var $TYPE_RJ_EXPORT = Symbol('rj~export'); // The final rj runnable object
// rj(...)() or rj(... launched ->)

var $TYPE_RJ_OBJECT = Symbol('rj~object');

function forgeRocketJump(rjImpl) {
  // Here is where the magic starts the functional recursive rjs combining \*.*/
  function rj() {
    for (var _len = arguments.length, partialRjsOrConfigs = new Array(_len), _key = 0; _key < _len; _key++) {
      partialRjsOrConfigs[_key] = arguments[_key];
    }

    // ... make the partial config
    var partialConfig;

    if (typeof rjImpl.makePartialConfig === 'function') {
      // Implement the partial config on an Rj
      partialConfig = rjImpl.makePartialConfig(partialRjsOrConfigs);
    } else {
      // Standard merge config implementation
      partialConfig = mergeConfigs(partialRjsOrConfigs);
    } // Make the partial rj


    function PartialRj(extraConfig, extendExportArg, runRjImpl) {
      if (runRjImpl === void 0) {
        runRjImpl = rjImpl;
      }

      // Take the extended exports seriusly only when came from rj
      var extendExport;

      if (typeof extendExportArg === 'object' && extendExportArg !== null && extendExportArg.__rjtype === $TYPE_RJ_EXPORT) {
        extendExport = extendExportArg;
      } // true when rj(rj(), rj(), rj(), { })() the last rj of recursion is
      // evalutated


      var isLastRjInvocation = extendExport === undefined; // Final configuration

      var finalConfig = mergeConfigs([partialConfig, extraConfig]);
      var runConfig = runRjImpl.makeRunConfig(finalConfig);
      var recursionRjs = runRjImpl.makeRecursionRjs(partialRjsOrConfigs, extraConfig, isLastRjInvocation); // Make the continued export for combining

      var continuedExport;

      if (!extendExport) {
        continuedExport = {}; // Mark export as valid

        Object.defineProperty(continuedExport, '__rjtype', {
          value: $TYPE_RJ_EXPORT
        });
      } else {
        continuedExport = extendExport;
      } // Invoke all rjs and configs and merge returned exports
      // ... yeah a mindfuck but is coool. ..


      var finalExport = recursionRjs.reduce(function (combinedExport, rjOrConfig) {
        if (typeof rjOrConfig === 'function') {
          // Is a partial rj jump it!
          return rjOrConfig(runConfig, combinedExport, runRjImpl);
        } else {
          // Is a config ... run config + jump config = export
          var newExport = runRjImpl.makeExport(runConfig, rjOrConfig, combinedExport); // Mark export as valid

          Object.defineProperty(newExport, '__rjtype', {
            value: $TYPE_RJ_EXPORT
          });
          return newExport;
        }
      }, continuedExport);

      if (isLastRjInvocation) {
        // Mark as an Rj Object that can be runned into
        // rj-react
        // or mount on redux / saga
        var rjObject = runRjImpl.finalizeExport(finalExport, runConfig, finalConfig);
        Object.defineProperty(rjObject, '__rjtype', {
          value: $TYPE_RJ_OBJECT
        }); // Ship the last config in rj chain

        Object.defineProperty(rjObject, '__rjconfig', {
          value: partialConfig
        }); // Attach the RJ Implementation to rj object! Fuck YEAH!

        Object.defineProperty(rjObject, '__rjimplementation', {
          value: rjImpl
        });
        return rjObject;
      } else {
        return finalExport;
      }
    } // Create a rocketjump object at first invocation when is needed


    if (typeof rjImpl.shouldRocketJump === 'function' && rjImpl.shouldRocketJump(partialRjsOrConfigs)) {
      return PartialRj();
    } // Mark the partialRj


    Object.defineProperty(PartialRj, '__rjtype', {
      value: $TYPE_RJ_PARTIAL
    });
    Object.defineProperty(PartialRj, '__rjconfig', {
      value: partialConfig
    }); // Attach the RJ Implementation to rj partial! Fuck YEAH!

    Object.defineProperty(PartialRj, '__rjimplementation', {
      value: rjImpl
    });
    return PartialRj;
  } // Attach the RJ Implementation to rj constructor! Fuck YEAH!


  Object.defineProperty(rj, '__rjimplementation', {
    value: rjImpl
  });
  return rj;
}

// Mark action as an action that trigger effects!
var EFFECT_ACTION = '@@RJ/EFFECT';
/**
 * Mark an action as an effect action
 * When an action is marked as an "effect action"
 *  in addition of being dispatched in the local rj store
 *  it is passed to the rj observable to interact with the side effect:
 *  run the side effect, cancel it etc...
 */

var makeEffectAction = function makeEffectAction(action) {
  Object.defineProperty(action, EFFECT_ACTION, {
    value: true
  });
  return action;
};
/**
 * Check if is an effect action
 */


var isEffectAction = function isEffectAction(action) {
  return action[EFFECT_ACTION] === true;
};
/**
 * Powerful helper to work with metadata
 * Its arg can either be a plain object, in which case it is merged in , or a function, in which
 *  case meta is hard set to the return value of the function
 */

function withMeta$1(meta) {
  var out = makeEffectAction(_extends({}, this, {
    meta: typeof meta === 'function' ? meta(this.meta) : _extends({}, this.meta, meta)
  }));
  out.extend = extend.bind(out);
  out.withMeta = withMeta$1.bind(out);
  return out;
}
/**
 * This function allows to inject some extra params in a library action
 * It is a delicate operation, since it works by constructing a new action object
 * and rebinding the operations (extends and withMeta) to it
 */


function extend(extensions) {
  var out = makeEffectAction(_extends({}, this, {
    meta: _extends({}, this.meta, extensions.meta),
    callbacks: {
      onSuccess: extensions.callbacks && extensions.callbacks.onSuccess,
      onFailure: extensions.callbacks && extensions.callbacks.onFailure
    }
  }));
  out.extend = extend.bind(out);
  out.withMeta = withMeta$1.bind(out);
  return out;
}
/**
 * Creates a new library action
 * A library action is a predefined action that can be handled in the context of rocketjump side effect model
 * Such actions are wired into the library and are extremely general: customization with the `actions` directive
 * is provided in order to adapt them (and their interface and behaviour) to user needs
 */


function makeLibraryAction(type) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }

  var baseObject = makeEffectAction({
    type: type,
    payload: {
      params: params
    },
    meta: {},
    callbacks: {
      onSuccess: undefined,
      onFailure: undefined
    }
  });
  baseObject.extend = extend.bind(baseObject);
  baseObject.withMeta = withMeta$1.bind(baseObject);
  return baseObject;
}

function mergeCallbacks(curriedCallbacks, callbacks) {
  var mergedCallbacks = {};

  if (curriedCallbacks.onSuccess) {
    mergedCallbacks.onSuccess = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      curriedCallbacks.onSuccess.concat(callbacks.onSuccess || []).forEach(function (cb) {
        cb.apply(void 0, args);
      });
    };
  } else if (callbacks.onSuccess) {
    mergedCallbacks.onSuccess = callbacks.onSuccess;
  }

  if (curriedCallbacks.onFailure) {
    mergedCallbacks.onFailure = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      curriedCallbacks.onFailure.concat(callbacks.onFailure || []).forEach(function (cb) {
        cb.apply(void 0, args);
      });
    };
  } else if (callbacks.onFailure) {
    mergedCallbacks.onFailure = callbacks.onFailure;
  }

  return mergedCallbacks;
}
/**
 * Builder pattern implementation for action creators calls
 * Its only aim is to decouple the invocation and the definition of params needed by the invocation itself
 * It is also the only way to leverage the rocketjump capabilities with full power
 */


var Builder = /*#__PURE__*/function () {
  function Builder(actionCreator, dispatch) {
    this.actionCreator = actionCreator;
    this.dispatch = dispatch;
    this.callbacks = {};
    this.metaTransforms = []; // Curry my Builder

    this.curriedCallbacks = {};
    this.curriedArgs = [];
  }

  var _proto = Builder.prototype;

  _proto.withMeta = function withMeta(meta) {
    if (typeof meta === 'function') {
      this.metaTransforms.push(meta);
    } else {
      this.metaTransforms.push(function (oldMeta) {
        return _extends({}, oldMeta, meta);
      });
    }

    return this;
  };

  _proto.onSuccess = function onSuccess(callback) {
    this.callbacks.onSuccess = callback;
    return this;
  };

  _proto.onFailure = function onFailure(callback) {
    this.callbacks.onFailure = callback;
    return this;
  };

  _proto.curry = function curry() {
    var metaTransforms = [].concat(this.metaTransforms);

    var callbacks = _extends({}, this.callbacks);

    var curriedCallbacks = _extends({}, this.curriedCallbacks);

    for (var _len3 = arguments.length, curryArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      curryArgs[_key3] = arguments[_key3];
    }

    var nextArgs = this.curriedArgs.concat(curryArgs);

    var makeBuilder = function makeBuilder() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      var builder = _construct(Builder, args);

      builder.metaTransforms = metaTransforms;
      builder.callbacks = {};
      builder.curriedCallbacks = {
        onSuccess: curriedCallbacks.onSuccess || callbacks.onSuccess ? [].concat(curriedCallbacks.onSuccess || []).concat(callbacks.onSuccess || []) : undefined,
        onFailure: curriedCallbacks.onFailure || callbacks.onFailure ? [].concat(curriedCallbacks.onFailure || []).concat(callbacks.onFailure || []) : undefined
      };
      builder.curriedArgs = nextArgs;
      return builder;
    };

    var frozenBobBuilder = makeBuilder(this.actionCreator, this.dispatch);
    var boundActionCreator = frozenBobBuilder.run.bind(frozenBobBuilder);
    return attachBuilder(boundActionCreator, this.actionCreator, this.dispatch, makeBuilder);
  };

  _proto.run = function run() {
    for (var _len5 = arguments.length, argsWithDepsLocal = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      argsWithDepsLocal[_key5] = arguments[_key5];
    }

    var argsWithDeps = this.curriedArgs.concat(argsWithDepsLocal); // Deps can't be runned

    if (!shouldRunDeps(argsWithDeps)) {
      return;
    } // Squash meta into values


    var args = getRunValuesFromDeps(argsWithDeps);
    var action = this.actionCreator.apply(this, args);

    if (isEffectAction(action)) {
      var callbacks = mergeCallbacks(this.curriedCallbacks, this.callbacks);
      action = action.extend({
        callbacks: callbacks
      }); // Apply meta from deps

      var extraMetaFromDeps = getMetaFromDeps(argsWithDeps, null, // No prev args
      false // Not on "mount"
      );
      action = action.withMeta(extraMetaFromDeps); // Apply meta from Builder .withMeta().withMeta()

      action = this.metaTransforms.reduce(function (action, transform) {
        return action.withMeta(transform);
      }, action); // Remove *magic* stuff

      delete action.extend;
      delete action.withMeta;
    }

    this.dispatch(action);
  };

  _proto.asPromise = function asPromise() {
    var _this = this;

    for (var _len6 = arguments.length, argsLocal = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      argsLocal[_key6] = arguments[_key6];
    }

    var args = this.curriedArgs.concat(argsLocal);
    var callbacks = mergeCallbacks(this.curriedCallbacks, this.callbacks);
    return new Promise(function (resolve, reject) {
      var action = _this.actionCreator.apply(_this, args);

      if (isEffectAction(action)) {
        action = action.extend({
          callbacks: {
            onSuccess: function onSuccess() {
              if (callbacks.onSuccess) {
                callbacks.onSuccess.apply(callbacks, arguments);
              }

              resolve.apply(void 0, arguments);
            },
            onFailure: function onFailure() {
              if (callbacks.onFailure) {
                callbacks.onFailure.apply(callbacks, arguments);
              }

              reject.apply(void 0, arguments);
            }
          }
        });
        action = _this.metaTransforms.reduce(function (action, transform) {
          return action.withMeta(transform);
        }, action);
        delete action.extend;
        delete action.withMeta;

        _this.dispatch(action);
      } else {
        _this.dispatch(action);

        resolve();
      }
    });
  };

  return Builder;
}();
/**
 * This function is used to attach a builder to an action creator
 * To attach a builder means to add some methods on the function object that reflect the builder class interface
 * in order to have a unique interface. This methods simply create a new builder and call the corresponding method
 * on the builder itself. This is necessary because directly attaching the builder logic to the action creator
 * would lead to some data being reused across advanced calls, and this is not intended to happen.
 *
 * The run method throws an exception just to give the user a nicer feedback on the error he/she would receive
 *  in case of bad invocation
 */


function attachBuilder(boundActionCreator, actionCreator, dispatch, makeBuilder) {
  if (makeBuilder === void 0) {
    makeBuilder = function makeBuilder() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return _construct(Builder, args);
    };
  }

  boundActionCreator.onSuccess = function (callback) {
    return makeBuilder(actionCreator, dispatch).onSuccess(callback);
  };

  boundActionCreator.onFailure = function (callback) {
    return makeBuilder(actionCreator, dispatch).onFailure(callback);
  };

  boundActionCreator.withMeta = function (meta) {
    return makeBuilder(actionCreator, dispatch).withMeta(meta);
  };

  boundActionCreator.curry = function () {
    var _makeBuilder;

    return (_makeBuilder = makeBuilder(actionCreator, dispatch)).curry.apply(_makeBuilder, arguments);
  };

  boundActionCreator.run = function () {
    throw new Error('In order to do a plain call without meta, onSuccess or onFailure, just invoke the action creator, use the run method only when you leverage the builder functionalities');
  };

  boundActionCreator.asPromise = function () {
    var _makeBuilder2;

    return (_makeBuilder2 = makeBuilder(actionCreator, dispatch)).asPromise.apply(_makeBuilder2, arguments);
  };

  return boundActionCreator;
}
/**
 * Binds a single action creator to the dispatch dynamics, and returns a function able to dispatch
 *  the generated action when invoked
 *
 * An action creator provided by rocketjump will be dispatched in the context of rocketjump side effect model,
 *  while a standard plain action will be directly sent to the reducer
 *
 * Every action is attached a builder in order to allow for calling with more options
 *
 * By default, arguments passed directly to the function are sent in the `params` property of the action
 * If there is the need to attach some metadata or some callbacks to the action, the action must be dispatched
 *  using the builder. It is important to underline that the builder works only on rocketjump async actions
 *  (i.e. the predefined actions plus all the overrides obtained with the `actions` directive in configuration).
 *  If builder methods are invoked on plain actions, they'll simply have no effect.
 *
 * Hence, it is possible to dispatch an action in two ways, described by the following example (in which the action
 *  is called action)
 *
 * Basic call:
 * action(arg1, arg2, arg3, ...)
 *
 * Advanced call:
 * action
 *   .withMeta({ meta1: value1, meta2: value2 })
 *   .withMeta({ meta3 : value3 })
 *   .onSuccess(successHandler)
 *   .onFailure(failureHander)
 *   .run(arg1, arg2, arg3, ...)
 *
 * The basic call has no way to leverage `meta`, `onSuccess` or `onFailure` features provided by the library
 *
 * In the advanced call it is possible to call the three methods `withMeta`, `onSuccess` and `onFailure` in
 *  any order and even more than one time: the callbacks are overwritten, and meta transformation are stacked.
 *  It is mandatory that the last method of the call is the `run` method, which takes the
 *  arguments to be passed to the action creator. Apart from the `run` method, the advanced call must contain
 *  at least one other method among those documented here in order to be valid. In other words, the call
 *
 *  action.run(arg1, arg2, arg3)
 *
 *  is not valid in will raise an exception. It is in fact meaningless to dispatch an action in this way, since
 *  it would be semantically equivalent but more verbose with respect to the direct call action(arg1, arg2, arg3)
 *
 *  A note about meta transformations:
 *    the withMeta helper accepts either a plain object or a function. In case of function, that function will
 *    be invoked with the previous meta object as a parameter, and is expected to return the next meta object,
 *    which will overwrite the previous one. If instead it is given a plain object, its behaviour is equivalent
 *    of giving a function that spreads the object over the previous meta, and returns the result, such as
 *
 *    withMeta(obj) is equivalent to withMeta(oldMeta => ({ ...oldMeta, ...obj }))
 *
 */


function bindActionCreator(actionCreator, dispatch) {
  var out = function out() {
    for (var _len8 = arguments.length, argsWithDeps = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      argsWithDeps[_key8] = arguments[_key8];
    }

    // Deps can't be runned
    if (!shouldRunDeps(argsWithDeps)) {
      return;
    } // Squash meta into values


    var args = getRunValuesFromDeps(argsWithDeps);
    var action = actionCreator.apply(void 0, args);

    if (isEffectAction(action)) {
      // Apply meta from deps
      var extraMetaFromDeps = getMetaFromDeps(argsWithDeps, null, // No prev args
      false // Not on "mount"
      );
      action = action.withMeta(extraMetaFromDeps);
      delete action.extend;
      delete action.withMeta;
      dispatch(action);
    } else {
      dispatch(action);
    }
  };

  return attachBuilder(out, actionCreator, dispatch);
}
/**
 * This function is used to bind action creators to the dispatch dynamics
 * The user will be returned a function that, when invoked, will care of dispatching
 *  the corresponding action
 *
 * Both plain actions and rocketjump actions can be bound in this way
 */


function bindActionCreators(actionCreators, dispatch) {
  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];
    boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
  }

  return boundActionCreators;
}

// This is only a syntax sugar over useRj and useEffect,
// you can create your own helper, we think this is the most "useful" version
// from our point of view.

function createUseRunRj(useRj) {
  return function useRunRj(rjObject, runArgs, shouldCleanOnNewEffect) {
    if (runArgs === void 0) {
      runArgs = [];
    }

    if (shouldCleanOnNewEffect === void 0) {
      shouldCleanOnNewEffect = true;
    }

    for (var _len = arguments.length, params = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      params[_key - 3] = arguments[_key];
    }

    var _useRj = useRj.apply(void 0, [rjObject].concat(params)),
        state = _useRj[0],
        originalActions = _useRj[1];

    var run = originalActions.run,
        clean = originalActions.clean;

    var _useState = useState({}),
        withMeta = _useState[0],
        setWithMeta = _useState[1];

    var prevWithMeta = useRef(null);
    var runValues = getRunValuesFromDeps(runArgs);
    var prevRunValues = useRef(null);
    useEffect(function () {
      // Should run?
      var shouldRun = shouldRunDeps(runArgs);

      if (shouldRun) {
        var _run$withMeta;

        var meta = getMetaFromDeps(runArgs, prevRunValues.current); // Add meta only if setWithMeta in called along with last args update

        var hackRunWithMeta = {};

        if (prevWithMeta.current && prevWithMeta.current !== withMeta) {
          hackRunWithMeta = withMeta;
        }

        (_run$withMeta = run.withMeta(_extends({}, meta, hackRunWithMeta))).run.apply(_run$withMeta, runValues);
      }

      prevRunValues.current = runValues;
      prevWithMeta.current = withMeta;
      return function () {
        if (shouldCleanOnNewEffect && shouldRun) {
          clean();
        }
      }; // spreading run arguments as deps means:
      // every time a run arguments changes (Object.is comparison)
      // a run is triggered and (if configured) a clean to clean up
      // the old effect related state
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [clean, run, shouldCleanOnNewEffect].concat(runValues));
    var actions = useMemo(function () {
      return _extends({}, originalActions, {
        withNextMeta: setWithMeta
      });
    }, [setWithMeta, originalActions]);
    return useMemo(function () {
      return [state, actions];
    }, [state, actions]);
  };
}

function createComputeState(computed) {
  // No computed config provided
  if (!(typeof computed === 'object' && computed !== null)) {
    return null;
  } // Pre calculate computed keys 2 speed up computeState function


  var computedKeys = Object.keys(computed);
  /**
    Compute state according 2 computed config merged by:
     rj({
      computed: {
        ...
        [key2Compute]: '<selectorName>',
        ...
      }
    })
     computed the arguments of this function has key/value inverted so:
     {
      ...
      [selecortName]: '<key2Compute>',
      ...
    }
  */

  return function computeState(state, selectors) {
    return computedKeys.reduce(function (computedState, selectorName) {
      var _extends2;

      var keyName = computed[selectorName];
      var selector = selectors[selectorName];

      if (selector === undefined) {
        throw new Error("[rocketjump] you specified a non existing selector [" + selectorName + "] " + "check your computed config.");
      }

      return _extends({}, computedState, (_extends2 = {}, _extends2[keyName] = selector(state), _extends2));
    }, {});
  };
}

var PlaceholderValue = function PlaceholderValue(index) {
  this.index = index;
};

var LazyValue = /*#__PURE__*/function () {
  function LazyValue(valueConfig, exportValue, configValue) {
    this.valueConfig = valueConfig;
    this.exportValue = exportValue;
    this.placeholdersCount = 1;
    this.chain = [new PlaceholderValue(0)];
  }

  var _proto = LazyValue.prototype;

  _proto.add = function add(configValue) {
    var _this$valueConfig = this.valueConfig,
        shouldCompose = _this$valueConfig.shouldCompose,
        isLazy = _this$valueConfig.isLazy;

    if (isLazy(configValue)) {
      this.chain.push(new PlaceholderValue(this.placeholdersCount));
      this.placeholdersCount++;
    } else if (shouldCompose(configValue)) {
      this.chain.push(configValue);
    }
  };

  _proto.squashValue = function squashValue(placeholders) {
    var compose = this.valueConfig.compose;
    return this.chain.reduce(function (exportValue, valueOrPlaceholder) {
      var value;

      if (valueOrPlaceholder instanceof PlaceholderValue) {
        value = placeholders[valueOrPlaceholder.index];
      } else {
        value = valueOrPlaceholder;
      }

      return compose(exportValue, value);
    }, this.exportValue);
  };

  return LazyValue;
}(); // Configure the export value


function makeExportValue(_ref) {
  var defaultValue = _ref.defaultValue,
      isLazy = _ref.isLazy,
      shouldCompose = _ref.shouldCompose,
      compose = _ref.compose;
  return function (exportValue, configValue) {
    // Assing a default value to export value
    var nextValue;

    if (exportValue === undefined) {
      nextValue = defaultValue;
    } else {
      nextValue = exportValue;
    }

    if (nextValue instanceof LazyValue) {
      nextValue.add(configValue);
      return nextValue;
    } else {
      // The prev export is normal in recursion chain
      // Lazy placeholder
      if (isLazy(configValue)) {
        return new LazyValue({
          shouldCompose: shouldCompose,
          isLazy: isLazy,
          compose: compose
        }, exportValue, configValue);
      } // Normal composition


      if (shouldCompose(configValue)) {
        return compose(nextValue, configValue);
      } else {
        return nextValue;
      }
    }
  };
}
function squashExportValue(value, placeholders) {
  if (value instanceof LazyValue) {
    return value.squashValue(placeholders);
  } else {
    return value;
  }
}

function isPartialRj(partialRj, rj) {
  if (typeof partialRj === 'function') {
    if (partialRj.__rjtype !== $TYPE_RJ_PARTIAL) {
      return false;
    } // When a rj is given check for same rj implementation!


    if (typeof rj === 'function') {
      return rj.__rjimplementation === partialRj.__rjimplementation;
    } else {
      return true;
    }
  }

  return false;
}
function isObjectRj(objRj, rj) {
  if (objRj !== null && typeof objRj === 'object') {
    if (objRj.__rjtype !== $TYPE_RJ_OBJECT) {
      return false;
    } // When a rj is given check for same rj implementation!


    if (typeof rj === 'function') {
      return rj.__rjimplementation === objRj.__rjimplementation;
    } else {
      return true;
    }
  }

  return false;
}

var deps = _extends({}, allDeps); // Remove es6 module shit

export { bindActionCreators, createComputeState, createUseRunRj, deps, forgeRocketJump, getMetaFromDeps, getRunValuesFromDeps, isEffectAction, isObjectRj, isPartialRj, makeExportValue, makeLibraryAction, shouldRunDeps, squashExportValue };
