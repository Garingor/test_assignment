import _extends from '@babel/runtime/helpers/esm/extends';

var arrayze = function arrayze(a) {
  return Array.isArray(a) ? a : [a];
}; // Object path getter

function get(obj, path, defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = undefined;
  }

  var keys = path.split('.');
  var result = obj === null ? undefined : keys.reduce(function (context, current) {
    return context[current];
  }, obj);
  return result === undefined ? defaultValue : result;
} // Invert object keys with values

function invertKeys(object) {
  return Object.keys(object).reduce(function (inverted, key) {
    var _extends2;

    return _extends({}, inverted, (_extends2 = {}, _extends2[object[key]] = key, _extends2));
  }, {});
} // Simple merge and skip when function....

function mergeConfigs(rjsOrConfigs) {
  return rjsOrConfigs.reduce(function (finalConfig, config) {
    if (typeof config === 'function') {
      return finalConfig;
    }

    return _extends({}, finalConfig, config);
  }, {});
} // Thanks lodash

function mapValues(object, iteratee) {
  object = Object(object);
  var result = {};
  Object.keys(object).forEach(function (key) {
    result[key] = iteratee(object[key], key, object);
  });
  return result;
} // Proxy an object of fucntions

var proxyObject = function proxyObject(obj, proxy) {
  if (typeof proxy === 'function') {
    return _extends({}, obj, proxy(obj));
  }

  if (typeof proxy === 'object' && proxy !== null) {
    return _extends({}, obj, mapValues(proxy, function (proxyFn) {
      return proxyFn(obj);
    }));
  }

  return obj;
}; // Compose functions

var kompose = function kompose() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function (x) {
    return fns.reduce(function (v, f) {
      return f(v);
    }, x);
  };
};
var proxyReducer = function proxyReducer(reducer, proxyFn) {
  if (typeof proxyFn === 'function') {
    for (var _len2 = arguments.length, extraArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      extraArgs[_key2 - 2] = arguments[_key2];
    }

    return proxyFn.apply(void 0, [reducer].concat(extraArgs));
  }

  return reducer;
};
var mergeActionPatterns = function mergeActionPatterns() {
  for (var _len3 = arguments.length, patterns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    patterns[_key3] = arguments[_key3];
  }

  return patterns.reduce(function (finalPattern, pattern) {
    return [].concat(finalPattern, arrayze(pattern));
  }, []);
};
var matchActionPattern = function matchActionPattern(action, pattern) {
  return pattern === '*' || arrayze(pattern).indexOf(action.type) !== -1;
};
var composeReducers = function composeReducers() {
  for (var _len4 = arguments.length, reducers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    reducers[_key4] = arguments[_key4];
  }

  return function (prevState, action) {
    return reducers.reduce(function (nextState, reducer) {
      if (typeof prevState === 'undefined') {
        // When le fukin prevState is undefined merge reducers
        // initial states... Cekka
        return _extends({}, nextState, reducer(undefined, action));
      } else {
        return reducer(nextState, action);
      }
    }, prevState);
  };
};

export { arrayze, composeReducers, get, invertKeys, kompose, mapValues, matchActionPattern, mergeActionPatterns, mergeConfigs, proxyObject, proxyReducer };
