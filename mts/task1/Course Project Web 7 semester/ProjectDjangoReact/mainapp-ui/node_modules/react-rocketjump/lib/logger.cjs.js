'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('rxjs');
var _debugger = require('./debugger-1b0f24ff.js');

function whereMyRjIsIvoked(wrappedComponentName) {
  var originalStackLimit = Error.stackTraceLimit;
  var stack;
  Error.stackTraceLimit = Infinity;

  try {
    throw new Error();
  } catch (e) {
    stack = e.stack.split('\n');
  }

  Error.stackTraceLimit = originalStackLimit;

  var parseStackLine = function parseStackLine(line) {
    var cleanLine = line.trim();

    if (cleanLine.indexOf('at') === 0) {
      var pieces = cleanLine.split(' ');
      return pieces.slice(1);
    }

    return ['', ''];
  };

  stack = stack.slice(1).map(parseStackLine);
  var startedMainHook = false;
  var rjHooks = ['useRj', 'useRunRj'];
  var hooks = [];
  var rjFn = ''; // console.log(stack)

  for (var i = 0; i < stack.length; i++) {
    var _stack$i = stack[i],
        functionName = _stack$i[0]; // console.log(functionName)

    if (!startedMainHook && functionName === 'useMiniRedux') {
      startedMainHook = true;
    } else if (startedMainHook) {
      if (rjHooks.indexOf(functionName) !== -1) {
        rjFn = functionName;
      } else if (functionName.indexOf('use') === 0) {
        hooks.push(functionName);
      } else {
        // connectRj
        if (wrappedComponentName) {
          return {
            component: "<" + wrappedComponentName + " />",
            hooks: hooks,
            rjFn: 'connectRj'
          };
        } // First non hook from useMiniRedux


        return {
          component: "<" + functionName + " />",
          hooks: hooks,
          rjFn: rjFn
        };
      }
    }
  }

  return {
    component: '',
    hooks: hooks,
    rjFn: rjFn
  };
}

function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';

  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }

  return color;
}

var colors = Array.apply(null, {
  length: 100
}).map(getRandomColor);

var pad = function pad(n) {
  return Array.apply(null, {
    length: n
  }).join(' ');
};

function rjLogger() {
  var rjLives = [];
  var whereUsed = {};

  function lazyInitRjInstance(event) {
    if (whereUsed[event.meta.trackId] === undefined) {
      whereUsed[event.meta.trackId] = whereMyRjIsIvoked(event.meta.info.wrappedComponentName);
    }

    if (rjLives.indexOf(event.meta.info) === -1) {
      rjLives.push(event.meta.info);
    }
  }

  _debugger.RjDebugEvents.subscribe(function (event) {
    if (event.type === _debugger.RJ_INIT_EVENT) {
      lazyInitRjInstance(event);
    } else if (event.type === _debugger.RJ_TEARDOWN_EVENT) {
      var index = rjLives.indexOf(event.meta.info);

      if (index !== -1) {
        rjLives.splice(index, 1);
      }

      delete whereUsed[event.meta.trackId];
    } else if (event.type === _debugger.RJ_DISPATCH_EVENT) {
      lazyInitRjInstance(event);
      var _event$meta = event.meta,
          info = _event$meta.info,
          trackId = _event$meta.trackId;

      var _index = rjLives.indexOf(info);

      var location = whereUsed[trackId];
      var rjName = info.name || _index + 1 + "\xB0";
      var component = location.component,
          rjFn = location.rjFn,
          hooks = location.hooks;
      var componentLocation = "%c" + component + "%c" + hooks.map(function (h) {
        return "  " + h + "()";
      }).reverse().join('') + "  " + rjFn + "(" + rjName + ")";
      var color = colors[trackId % colors.length];
      var _event$payload = event.payload,
          action = _event$payload.action,
          prevState = _event$payload.prevState,
          nextState = _event$payload.nextState;
      console.groupCollapsed(componentLocation + "  %caction %c" + action.type, 'color: #80338a;font-weight:normal', "color:" + color + ";font-weight:normal", 'color:grey;font-weight:lighter;', 'color:#464646;');
      console.log("%cprev state", 'color: grey;font-weight:normal;', prevState);
      console.log("%caction " + pad(4), 'color:deepskyblue;font-weight:normal;', action);
      console.log("%cnext state", 'color: green;font-weight:normal;', nextState); // console.log(`%c_rj ${pad(7)}`, 'color: grey', {
      //   debugTrackId: trackId,
      //   lastRjConfig: info
      // })

      console.groupEnd();
    } else if (event.type === _debugger.RJ_ERROR_EVENT) {
      lazyInitRjInstance(event);
      var _event$meta2 = event.meta,
          _info = _event$meta2.info,
          _trackId = _event$meta2.trackId;

      var _index2 = rjLives.indexOf(_info);

      var _location = whereUsed[_trackId];

      var _rjName = _info.name || _index2 + 1 + "\xB0";

      var _component = _location.component,
          _rjFn = _location.rjFn,
          _hooks = _location.hooks;

      var _componentLocation = "" + _component + _hooks.map(function (h) {
        return "  " + h + "()";
      }) + "  " + _rjFn + "(" + _rjName + ")";

      var error = event.payload;
      console.error("[react-rocketjump] in " + _componentLocation + "\n  " + error);
    }
  });
}

var logger;

if (process.env.NODE_ENV === 'production') {
  // Noop logger
  logger = function logger() {};
} else {
  // Dev logger
  logger = rjLogger;
}

var logger$1 = logger;

exports.default = logger$1;
