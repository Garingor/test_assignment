import _extends from '@babel/runtime/helpers/esm/extends';
import '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { isEffectAction, isObjectRj as isObjectRj$1, bindActionCreators, createUseRunRj } from 'rocketjump-core';
export { deps, makeLibraryAction as makeAction } from 'rocketjump-core';
import { S as SUCCESS, F as FAILURE, P as PENDING, R as RJ_CONFIG_PLACEHOLDER, I as INIT, r as rj } from './rj-8a6e6805.js';
export { c as CANCEL, C as CLEAN, F as FAILURE, I as INIT, P as PENDING, b as RUN, a as RxEffects, S as SUCCESS, U as UPDATE_DATA, r as rj } from './rj-8a6e6805.js';
import { ReplaySubject } from 'rxjs';
import { publish } from 'rxjs/operators';
import 'rocketjump-core/utils';
import '@babel/runtime/helpers/esm/inheritsLoose';
import { del } from 'object-path-immutable';
import React, { useRef, useReducer, useEffect, useContext, useDebugValue, useMemo } from 'react';
import { A as AllRjEventsSubject, R as RJ_INIT_EVENT, a as RJ_DISPATCH_EVENT, b as RJ_ERROR_EVENT, c as RJ_TEARDOWN_EVENT } from './debugger-ad70456b.js';
import hoistStatics from 'hoist-non-react-statics';

function singleMutationReducer(state, action) {
  if (state === void 0) {
    state = {
      pending: false,
      error: null
    };
  }

  switch (action.type) {
    case PENDING:
      return _extends({}, state, {
        error: null,
        pending: true
      });

    case FAILURE:
      return _extends({}, state, {
        error: action.payload,
        pending: false
      });

    case SUCCESS:
      return _extends({}, state, {
        pending: false
      });

    default:
      return state;
  }
}

function singleMutation(mutationConfig) {
  return _extends({
    reducer: singleMutationReducer,
    takeEffect: 'exhaust'
  }, mutationConfig);
}

function makeMultiMutationReducer(makeKey) {
  return function (state, action) {
    if (state === void 0) {
      state = {
        pendings: {},
        errors: {}
      };
    }

    switch (action.type) {
      case PENDING:
        {
          var _extends2;

          var key = makeKey.apply(void 0, action.meta.params);
          return {
            errors: del(state.errors, key),
            pendings: _extends({}, state.pendings, (_extends2 = {}, _extends2[key] = true, _extends2))
          };
        }

      case FAILURE:
        {
          var _extends3;

          var _key = makeKey.apply(void 0, action.meta.params);

          return {
            errors: _extends({}, state.errors, (_extends3 = {}, _extends3[_key] = action.payload, _extends3)),
            pendings: del(state.pendings, _key)
          };
        }

      case SUCCESS:
        {
          var _key2 = makeKey.apply(void 0, action.meta.params);

          return _extends({}, state, {
            pendings: del(state.pendings, _key2)
          });
        }

      default:
        return state;
    }
  };
}

function multi(makeKey, mutationConfig) {
  return _extends({
    reducer: makeMultiMutationReducer(makeKey),
    takeEffect: ['groupByExhaust', function (action) {
      return makeKey.apply(void 0, action.meta.params);
    }]
  }, mutationConfig);
}

var standardMutations = /*#__PURE__*/Object.freeze({
  __proto__: null,
  single: singleMutation,
  multi: multi
});

// Rj feature flags
var flags = {
  // mutations: true
  "debugger": true
};

function configured() {
  return RJ_CONFIG_PLACEHOLDER;
}
var mutation = _extends({}, standardMutations);

var configHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  configured: configured,
  mutation: mutation,
  flags: flags
});

// https://github.com/Andarist/use-constant

function useConstant(fn) {
  var ref = useRef();

  if (!ref.current) {
    ref.current = {
      v: fn()
    };
  }

  return ref.current.v;
}

var ConfigureRjContext = /*#__PURE__*/React.createContext(null);

var RjDebugEventEmitter = /*#__PURE__*/function () {
  function RjDebugEventEmitter(trackId, info) {
    this.trackId = trackId;
    this.info = info;
  }

  var _proto = RjDebugEventEmitter.prototype;

  _proto.emit = function emit(type, payload) {
    if (payload === void 0) {
      payload = {};
    }

    if (process.env.NODE_ENV !== 'production') {
      AllRjEventsSubject.next({
        type: type,
        meta: {
          trackId: this.trackId,
          info: this.info
        },
        payload: payload
      });
    }
  };

  _proto.onStateInitialized = function onStateInitialized(state) {
    this.emit(RJ_INIT_EVENT, {
      state: state
    });
  };

  _proto.onActionDispatched = function onActionDispatched(action, prevState, nextState) {
    this.emit(RJ_DISPATCH_EVENT, {
      action: action,
      prevState: prevState,
      nextState: nextState
    });
  };

  _proto.onError = function onError(error) {
    this.emit(RJ_ERROR_EVENT, error);
  };

  _proto.onTeardown = function onTeardown() {
    this.emit(RJ_TEARDOWN_EVENT);
  };

  return RjDebugEventEmitter;
}();

var trackIdUniq = 0;
function createEmitter(info) {
  var emitter = new RjDebugEventEmitter(trackIdUniq, info);

  if (process.env.NODE_ENV !== 'production') {
    trackIdUniq++;
  }

  return emitter;
} // Test utils to reset the trackIdUniq

// a reducer for handle state
// and the roboust rxjs to handle complex side effecs in a pure, declarative, fancy way!

function useMiniRedux(reducer, makeObservable, pipeActionStream, // debug information used as dev hints and other
debugInfo) {
  // Debug rj() \w classy (not in PROD)
  var debugEmitter = useConstant(function () {
    return createEmitter(debugInfo);
  }); // STATE$
  // emits state updates (used to build the $dispatch Observable)

  var _useConstant = useConstant(function () {
    var subject = new ReplaySubject();
    return [subject, subject.asObservable()];
  }),
      stateSubject = _useConstant[0],
      state$ = _useConstant[1]; // Init the reducer in the REDUX way
  // pass special INIT actions and undefined to our reducer


  function initReducer(initialArg) {
    var initialState = reducer(initialArg, {
      type: INIT
    });

    if (process.env.NODE_ENV === 'production') {
      return initialState;
    } else {
      if (!flags["debugger"]) {
        return initialState;
      } // In DEV call the debug emitter


      debugEmitter.onStateInitialized(initialState); // NOTE
      // First this mad shit happends only in DEV
      // Second the reason of this magic shit is because
      // call the reducer often than dispatch so logging the exact
      // sequence is impossible but since the purity nature of reducers
      // react call the reducer with the prev state in the exact sequence
      // and can do it based on the assumption of the purity of the reducer
      // so keeping an index in react state can helps us detect if the action
      // is alredy been dispatched and react simply re call the reducer to
      // have the state up date to render.
      // i am not to much secure of my toughts but if you back to point
      // one this stuff in only in DEV and don't change the other behaviurs
      // of how the state bheave.
      // the original ideas was from mad man Albi 1312.
      //
      // kepp a reference of current "dispatch index"
      // and the same value in reducer state

      state$.__dispatchIndex = 0;
      return {
        idx: 0,
        state: initialState
      };
    }
  }

  var proxyReducer;

  if (process.env.NODE_ENV === 'production') {
    proxyReducer = reducer;
  } else if (!flags["debugger"]) {
    proxyReducer = reducer;
  } else {
    // Proxy the original reducer
    // This is only a way to hook into the React updates
    // and grab state and action to
    // keep a reference of current state and emits state updates on observable
    // ... and call the Rj debug hooks using for example to have
    // a clear logging of state changes between times as the redux dev tools does
    proxyReducer = function proxyReducer(prevState, action) {
      var nextState = reducer(prevState.state, action); // emitStateUpdate(nextState)
      // The reducer always update the state and remain a pure function

      var idx = prevState.idx + 1; // if the new dispatch index is greater is a new action

      if (idx > state$.__dispatchIndex) {
        // Emit the debug hook
        debugEmitter.onActionDispatched(action, prevState.state, nextState); // keep the index at the last version

        state$.__dispatchIndex = idx;
      } // Always update the state in the same way a pure function lol


      return {
        idx: idx,
        state: nextState
      };
    };
  }

  var _useReducer = useReducer(proxyReducer, undefined, // the first argument of reducer is undefined in the redux way
  initReducer),
      stateAndIdx = _useReducer[0],
      dispatch = _useReducer[1];

  var state;

  if (process.env.NODE_ENV === 'production') {
    // No need in prod is directly the state
    state = stateAndIdx;
  } else if (!flags["debugger"]) {
    // Force turn off debugger features
    state = stateAndIdx;
  } else {
    // Grab the piece of original state
    state = stateAndIdx.state;
  } // Emit a state update to state$ Observable
  // ... keep a reference of current state


  useEffect(function () {
    state$.value = state;
    stateSubject.next(state);
  }, [state, state$, stateSubject]); // Extra shit from <ConfigureRj />

  var extraConfig = useContext(ConfigureRjContext);

  var _useConstant2 = useConstant(function () {
    // Why ReplaySubject?
    // in the old useMiniRedux implementation
    // subscription happened in the render phase
    // but as says ma men @bvaughn for the correct work
    // of upcoming async mode side effects are allowed 2 run
    // in the commit phase ...
    // Check this: https://github.com/facebook/react/tree/master/packages/use-subscription
    // thanks 2 ReplaySubject the action dispatched between the render and commit phase
    // are "re-played" and correct dispatched to our rx side effects or react reducer state
    var subject = new ReplaySubject();
    var actionObserable = subject.asObservable(); // Apply the effect pipeline
    // useful to change the "normal" action stream
    // ES:. here you can debounce, filter or other
    // stuff before the action trigger Y effect

    var rjPipedActionObservable = pipeActionStream(actionObserable, state$) // this ensure that the side effects inside effectPipeline
    // Es: tap(() => { sideEffect() })
    // are excuted only once
    // in the older implementation this mechanism was in
    // createMakeRxObservable but this leads to a lot of bug and
    // mysterious behaviours now pubblish are excuted only once
    // in front of the original action observable
    .pipe(publish()); // Create the dispatch observable

    var _makeObservable = makeObservable(rjPipedActionObservable, state$, extraConfig ? extraConfig.effectCaller : undefined),
        dispatchObservable = _makeObservable[0],
        updateExtraSideEffectConfig = _makeObservable[1];

    return [subject, rjPipedActionObservable, dispatchObservable, updateExtraSideEffectConfig];
  }),
      actionSubject = _useConstant2[0],
      action$ = _useConstant2[1],
      dispatch$ = _useConstant2[2],
      updateExtraSideEffectConfig = _useConstant2[3]; // Update extra side effect config


  var notUpdateOnFirstMount = useRef(true);
  useEffect(function () {
    // Not update on first useEffect call because in alredy updated ...
    if (notUpdateOnFirstMount.current) {
      notUpdateOnFirstMount.current = false;
      return;
    } // Update the effect caller at run time <3
    // Now <ConfigureRj effectCaller={() => {}} />
    // can be an anonymous without breaking anything


    updateExtraSideEffectConfig({
      effectCaller: extraConfig.effectCaller
    });
  }, [extraConfig, updateExtraSideEffectConfig]); // Subscription 2 dispatch$

  useEffect(function () {
    var subscription = dispatch$.subscribe(function (action) {
      // Erase callbacks before dispatch on reducer
      var successCallback;

      if (action.successCallback) {
        successCallback = action.successCallback;
        delete action.successCallback;
      }

      var failureCallback;

      if (action.failureCallback) {
        failureCallback = action.failureCallback;
        delete action.failureCallback;
      } // Dispatch the cleaned action


      dispatch(action); // Run the callbacks if needed

      if (successCallback) {
        successCallback(action.payload.data);
      }

      if (failureCallback) {
        failureCallback(action.payload);
      }
    }, function (error) {
      // Detailed info about error ...
      var errorStr = 'An error occured during your effect';

      if (debugInfo.name) {
        errorStr += " located in rocketjump " + debugInfo.name + ".";
      } else {
        errorStr += '.';
      }

      if (process.env.NODE_ENV !== 'production' && flags["debugger"]) {
        debugEmitter.onError(errorStr);
      } else {
        console.error("[react-rocketjump] " + errorStr);
      }

      throw error;
    }); // Ok now we are ready to handle shit from dispatch$ observable!

    action$.connect();
    return function () {
      subscription.unsubscribe(); // Say good bye to debugger

      if (process.env.NODE_ENV !== 'production') {
        if (flags["debugger"]) {
          debugEmitter.onTeardown();
        }
      }
    };
  }, [action$, dispatch$, debugEmitter, debugInfo]); // Dispatch to reducer or start an effect

  var dispatchWithEffect = useConstant(function () {
    return function (action) {
      if (isEffectAction(action)) {
        // Emit action to given observable theese perform side
        // effect and emit action dispatched above by subscription
        actionSubject.next(action);
      } else {
        // Update the state \w given reducer
        dispatch(action);
      }
    };
  });
  return [state, dispatchWithEffect];
}

function useRj( // The returned value of rj(..., EFFECT)
rjObject, // A function|undefined to select state
// (state, memoizedSelectors, derivedState) => newDerivedState
selectState) {
  if (!isObjectRj$1(rjObject)) {
    throw new Error('[react-rocketjump] You should provide a rj object to useRj.');
  }

  var makeRxObservable = rjObject.makeRxObservable,
      pipeActionStream = rjObject.pipeActionStream,
      actionCreators = rjObject.actionCreators,
      reducer = rjObject.reducer,
      makeSelectors = rjObject.makeSelectors,
      computeState = rjObject.computeState;
  useDebugValue(rjObject.__rjconfig.name ? "rj(" + rjObject.__rjconfig.name + ")" : 'Rocks'); // The last config or rj recursion rj({},rj(),..,{},{<THIS>})
  // used as debug hints

  var rjDebugInfo = rjObject.__rjconfig;

  var _useMiniRedux = useMiniRedux(reducer, makeRxObservable, pipeActionStream, rjDebugInfo),
      state = _useMiniRedux[0],
      dispatch = _useMiniRedux[1]; // Bind actions \w dispatch


  var boundActionCreators = useConstant(function () {
    return bindActionCreators(actionCreators, dispatch);
  }); // Create per-rj-instance memoized selectors

  var memoizedSelectors = useConstant(function () {
    if (typeof selectState === 'function' || typeof computeState === 'function') {
      return makeSelectors();
    }
  }); // Derive the state

  var derivedState = useMemo(function () {
    var derivedState = state;

    if (typeof computeState === 'function') {
      derivedState = computeState(state, memoizedSelectors);
    }

    if (typeof selectState === 'function') {
      derivedState = selectState(state, memoizedSelectors, derivedState);
    }

    return derivedState;
  }, [state, memoizedSelectors, selectState, computeState]); // Memoize return value now can saftley used in React Context.Provider

  return useMemo(function () {
    return [derivedState, boundActionCreators];
  }, [derivedState, boundActionCreators]);
}

var useRunRj = createUseRunRj(useRj);

var defaultMapActionsToProps = function defaultMapActionsToProps(a) {
  return a;
};

function connectRj( // The returned value of rj(..., EFFECT)
rjObject, mapStateToProps, mapActionsToProps) {
  if (mapActionsToProps === void 0) {
    mapActionsToProps = defaultMapActionsToProps;
  }

  return function wrapWithConnect(WrappedComponent) {
    if (!isObjectRj$1(rjObject)) {
      throw new Error('[react-rocketjump] You should provide a rj object to connectRj.');
    }

    function ConnectFunction(props) {
      var makeRxObservable = rjObject.makeRxObservable,
          pipeActionStream = rjObject.pipeActionStream,
          actionCreators = rjObject.actionCreators,
          reducer = rjObject.reducer,
          makeSelectors = rjObject.makeSelectors,
          computeState = rjObject.computeState;
      var wrappedComponentName = WrappedComponent.name;
      var rjDebugInfo = useMemo(function () {
        return _extends({}, rjObject.__rjconfig, {
          wrappedComponentName: wrappedComponentName
        });
      }, [wrappedComponentName]);

      var _useMiniRedux = useMiniRedux(reducer, makeRxObservable, pipeActionStream, rjDebugInfo),
          state = _useMiniRedux[0],
          dispatch = _useMiniRedux[1];

      var memoizedSelectors = useConstant(function () {
        if (typeof mapStateToProps === 'function' || typeof computeState === 'function') {
          return makeSelectors();
        }
      });
      var stateDerivedProps = useMemo(function () {
        var derivedState = state;

        if (typeof computeState === 'function') {
          derivedState = computeState(state, memoizedSelectors);
        }

        if (typeof mapStateToProps === 'function') {
          derivedState = mapStateToProps(state, memoizedSelectors, props, derivedState);
        }

        return derivedState;
      }, [state, memoizedSelectors, computeState, props]);
      var boundActionCreators = useMemo(function () {
        return bindActionCreators(mapActionsToProps(actionCreators), dispatch);
      }, [dispatch, actionCreators]);
      return /*#__PURE__*/React.createElement(WrappedComponent, _extends({}, boundActionCreators, stateDerivedProps, props));
    }

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
    var displayName = "connectRj(" + wrappedComponentName + ")";
    ConnectFunction.displayName = displayName;
    var Connect = /*#__PURE__*/React.memo(ConnectFunction);
    return hoistStatics(Connect, WrappedComponent);
  };
}

// util 4 compose hocs compose(hoc1, hoc2)(Component) hoc2(hoc1(Component))
function compose() {
  for (var _len = arguments.length, hocs = new Array(_len), _key = 0; _key < _len; _key++) {
    hocs[_key] = arguments[_key];
  }

  return function (WrappedComponent) {
    return hocs.reduce(function (Component, hoc) {
      return hoc(Component);
    }, WrappedComponent);
  };
}

function ConfigureRj(_ref) {
  var children = _ref.children,
      effectCaller = _ref.effectCaller;
  var extraConfig = useMemo(function () {
    return {
      effectCaller: effectCaller
    };
  }, [effectCaller]);
  return /*#__PURE__*/React.createElement(ConfigureRjContext.Provider, {
    value: extraConfig
  }, children);
}

function isObjectRj(objRj) {
  return isObjectRj$1(objRj, rj);
}

// Our main builder the MagIK rj()

for (var name in configHelpers) {
  rj[name] = configHelpers[name];
} // Exports Rj \w helpers

export { ConfigureRj, compose, connectRj, isObjectRj, useRj, useRunRj };
