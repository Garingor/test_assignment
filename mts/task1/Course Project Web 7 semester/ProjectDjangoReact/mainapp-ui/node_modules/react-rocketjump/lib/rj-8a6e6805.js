import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { makeExportValue, makeLibraryAction, squashExportValue, forgeRocketJump, isPartialRj, isObjectRj, createComputeState } from 'rocketjump-core';
import { of, concat, merge, empty, BehaviorSubject, isObservable, throwError, from } from 'rxjs';
import { withLatestFrom, switchMap, takeUntil, filter, mergeMap, exhaustMap, groupBy, map, catchError } from 'rxjs/operators';
import { arrayze, get, kompose, proxyObject, proxyReducer, composeReducers, invertKeys } from 'rocketjump-core/utils';
import _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';
import { del } from 'object-path-immutable';

var INIT = '@@INIT';
var RUN = 'RUN';
var PENDING = 'PENDING';
var SUCCESS = 'SUCCESS';
var FAILURE = 'FAILURE';
var CLEAN = 'CLEAN';
var CANCEL = 'CANCEL';
var UPDATE_DATA = 'UPDATE_DATA';

var _RxEffects;

function takeUntilCancelAction(action$, prefix) {
  return takeUntil(action$.pipe(filter(function (action) {
    return action.type === prefix + CLEAN || action.type === prefix + CANCEL;
  })));
}

var TAKE_EFFECT_LATEST = 'latest';

function mapToLatest(action$, mapActionToObserable, prefix) {
  return switchMap(function (_ref) {
    var action = _ref[0],
        extraSideEffectConfig = _ref[1];

    // Switch Map take always the last task so cancel ecc are auto emitted
    if (action.type === prefix + CANCEL || action.type === prefix + CLEAN) {
      return of(action);
    }

    return concat(of(action), mapActionToObserable(action, extraSideEffectConfig)).pipe(takeUntilCancelAction(action$, prefix));
  });
}

function takeEffectLatest(action$, state$, extraSideEffectObs$, mapActionToObserable, effectTypeArgs, prefix) {
  return action$.pipe(withLatestFrom(extraSideEffectObs$), mapToLatest(action$, mapActionToObserable, prefix));
}

var TAKE_EFFECT_EVERY = 'every';

function takeEffectEvery(action$, state$, extraSideEffectObs$, mapActionToObserable, effectTypeArgs, prefix) {
  return action$.pipe(withLatestFrom(extraSideEffectObs$), mergeMap(function (_ref2) {
    var action = _ref2[0],
        extraSideEffectConfig = _ref2[1];

    // Marge Map take every
    if (action.type === prefix + CANCEL || action.type === prefix + CLEAN) {
      return of(action);
    }

    return concat(of(action), mapActionToObserable(action, extraSideEffectConfig).pipe(takeUntilCancelAction(action$, prefix)));
  }));
} // export const TAKE_EFFECT_QUEUE = 'queue'


function actionToExhaustObservableEffect(action$, extraSideEffectObs$, mapActionToObserable, prefix) {
  return merge(action$.pipe(mergeMap(function (action) {
    if (action.type === prefix + CANCEL || action.type === prefix + CLEAN) {
      return of(action);
    } else {
      return empty();
    }
  })), action$.pipe(withLatestFrom(extraSideEffectObs$), exhaustMap(function (_ref3) {
    var action = _ref3[0],
        extraSideEffectConfig = _ref3[1];

    if (action.type === prefix + CANCEL || action.type === prefix + CLEAN) {
      return empty();
    }

    return concat(of(action), mapActionToObserable(action, extraSideEffectConfig)).pipe(takeUntilCancelAction(action$, prefix));
  })));
}

var TAKE_EFFECT_EXHAUST = 'exhaust';

function takeEffectExhaust(action$, state$, extraSideEffectObs$, mapActionToObserable, effectTypeArgs, prefix) {
  return actionToExhaustObservableEffect(action$, extraSideEffectObs$, mapActionToObserable, prefix);
}

var TAKE_EFFECT_GROUP_BY = 'groupBy';

function takeEffectGroupBy(action$, state$, extraSideEffectObs$, mapActionToObserable, effectTypeArgs, prefix) {
  var groupByFn = effectTypeArgs[0];

  if (typeof groupByFn !== 'function') {
    throw new Error('[react-rj] when you choose the groupBy ' + 'takeEffect you must provide a function to group by the effect.');
  }

  return action$.pipe(groupBy(groupByFn), mergeMap(function ($group) {
    return $group.pipe(withLatestFrom(extraSideEffectObs$), mapToLatest($group, mapActionToObserable, prefix));
  }));
}

var TAKE_EFFECT_GROUP_BY_EXHAUST = 'groupByExhaust';

function takeEffectGroupByExhaust(action$, state$, extraSideEffectObs$, mapActionToObserable, effectTypeArgs, prefix) {
  var groupByFn = effectTypeArgs[0];

  if (typeof groupByFn !== 'function') {
    throw new Error('[react-rj] when you choose the groupByExhaust ' + 'takeEffect you must provide a function to group by the effect.');
  }

  return action$.pipe(groupBy(groupByFn), mergeMap(function ($group) {
    return actionToExhaustObservableEffect($group, extraSideEffectObs$, mapActionToObserable, prefix);
  }));
}

var RxEffects = (_RxEffects = {}, _RxEffects[TAKE_EFFECT_LATEST] = takeEffectLatest, _RxEffects[TAKE_EFFECT_EVERY] = takeEffectEvery, _RxEffects[TAKE_EFFECT_EXHAUST] = takeEffectExhaust, _RxEffects[TAKE_EFFECT_GROUP_BY] = takeEffectGroupBy, _RxEffects[TAKE_EFFECT_GROUP_BY_EXHAUST] = takeEffectGroupByExhaust, _RxEffects);

var RJ_CONFIG_PLACEHOLDER = Symbol("rj~placeholder");

var composeEffectCallers = function composeEffectCallers() {
  for (var _len = arguments.length, callers = new Array(_len), _key = 0; _key < _len; _key++) {
    callers[_key] = arguments[_key];
  }

  return function (effectCall) {
    function recursion(callers) {
      var effectCaller = callers[0],
          passCallers = callers.slice(1);

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      if (passCallers.length === 0) {
        return effectCaller.apply(void 0, [effectCall].concat(args));
      }

      return effectCaller.apply(void 0, [function () {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return recursion.apply(void 0, [passCallers].concat(args));
      }].concat(args));
    }

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return recursion.apply(void 0, [callers].concat(args));
  };
};

var makeSideEffectDescriptor = function makeSideEffectDescriptor() {
  return {
    takeEffect: [TAKE_EFFECT_LATEST],
    effectPipeline: []
  };
};
var exportEffectCaller = makeExportValue({
  defaultValue: undefined,
  isLazy: function isLazy(v) {
    return v === RJ_CONFIG_PLACEHOLDER;
  },
  shouldCompose: function shouldCompose(v) {
    return !!v;
  },
  compose: function compose(prevCaller, caller) {
    if (prevCaller) {
      return composeEffectCallers(prevCaller, caller);
    } else {
      return caller;
    }
  }
}); // Merge prev sideEffectDescriptor with given rj config return
// a new sideEffectDescriptor

var addConfigToSideEffectDescritor = function addConfigToSideEffectDescritor(sideEffectDescriptor, config) {
  var newSideEffectDescriptor = _extends({}, sideEffectDescriptor);

  if (config.effect) {
    newSideEffectDescriptor.effect = config.effect;
  }

  newSideEffectDescriptor.effectCaller = exportEffectCaller(sideEffectDescriptor.effectCaller, config.effectCaller);

  if (config.takeEffect) {
    newSideEffectDescriptor.takeEffect = arrayze(config.takeEffect);
  }

  if (typeof config.effectPipeline === 'function') {
    newSideEffectDescriptor.effectPipeline = newSideEffectDescriptor.effectPipeline.concat(config.effectPipeline);
  }

  return newSideEffectDescriptor;
};

function run() {
  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return makeLibraryAction.apply(void 0, [RUN].concat(params));
} // TODO params really make sense for clean?


function clean() {
  for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    params[_key2] = arguments[_key2];
  }

  return makeLibraryAction.apply(void 0, [CLEAN].concat(params));
} // TODO params really make sense for cancel?


function cancel() {
  for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    params[_key3] = arguments[_key3];
  }

  return makeLibraryAction.apply(void 0, [CANCEL].concat(params));
}

var updateData = function updateData(data) {
  return {
    type: UPDATE_DATA,
    payload: data
  };
};

var ActionCreators = {
  run: run,
  clean: clean,
  cancel: cancel,
  updateData: updateData
};

var defaultState = {
  pending: false,
  error: null,
  data: null
};
function reducer(prevState, action) {
  if (prevState === void 0) {
    prevState = defaultState;
  }

  var type = action.type;

  switch (type) {
    case PENDING:
      return _extends({}, prevState, {
        error: null,
        pending: true
      });

    case FAILURE:
      return _extends({}, prevState, {
        pending: false,
        error: action.payload
      });

    case SUCCESS:
      return _extends({}, prevState, {
        pending: false,
        data: action.payload.data
      });

    case CANCEL:
      return _extends({}, prevState, {
        pending: false
      });

    case CLEAN:
      // So easy if someone add some shit to state
      // simply preserve that keys!
      return _extends({}, prevState, defaultState);

    case UPDATE_DATA:
      return _extends({}, prevState, {
        data: action.payload
      });

    default:
      return prevState;
  }
}

// Barebone selectors for barebone reducer
function makeSelectors() {
  var getData = function getData(_ref) {
    var data = _ref.data;
    return data;
  };

  var isLoading = function isLoading(_ref2) {
    var pending = _ref2.pending;
    return pending;
  };

  var isPending = function isPending(_ref3) {
    var pending = _ref3.pending;
    return pending;
  };

  var getError = function getError(_ref4) {
    var error = _ref4.error;
    return error;
  };

  return {
    getData: getData,
    isLoading: isLoading,
    isPending: isPending,
    getError: getError
  };
}

// Stolen from https://github.com/reduxjs
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers);
  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

var MUTATION_PREFIX = '@MUTATION';

function enhanceReducer(mutations, reducer, actionCreators) {
  var handleMutationsReducers = Object.keys(mutations).reduce(function (handlers, name) {
    var mutation = mutations[name];
    var update, optimisticUpdate;

    if (typeof mutation.optimisticUpdater === 'function' || typeof mutation.optimisticUpdater === 'string') {
      // Got optimisticUpdater
      // Check optimisticResult to be define when got optimisticUpdater
      if (typeof mutation.optimisticResult !== 'function') {
        if (process.env.NODE_ENV === 'production') {
          throw new Error('[react-rocketjump] @mutations error.');
        } else {
          throw new Error('[react-rocketjump] @mutations you should define optimisticUpdater ' + ("along with optimisticResult check your mutation config [" + name + "]."));
        }
      } // Check for good optimisticUpdater action creator


      if (typeof mutation.optimisticUpdater === 'string') {
        var actionCreator = actionCreators[mutation.optimisticUpdater];

        if (typeof actionCreator !== 'function') {
          if (process.env.NODE_ENV === 'production') {
            throw new Error('[react-rocketjump] @mutations error.');
          } else {
            throw new Error("[react-rocketjump] @mutations you provide a non existing " + ("action creator [" + mutation.updater + "] as optimisticUpdater for mutation [" + name + "]."));
          }
        } // Use action creator as optmistic update handler


        optimisticUpdate = function optimisticUpdate(state, action) {
          return reducer(state, actionCreator(action.payload.data));
        };
      } else {
        optimisticUpdate = function optimisticUpdate(state, action) {
          return mutation.optimisticUpdater(state, action.payload.data);
        };
      }
    } // No optimisticUpdater
    // Check for good updater


    if (typeof mutation.updater === 'string') {
      var _actionCreator = actionCreators[mutation.updater];

      if (typeof _actionCreator !== 'function') {
        if (process.env.NODE_ENV === 'production') {
          throw new Error('[react-rocketjump] @mutations error.');
        } else {
          throw new Error("[react-rocketjump] @mutations you provide a non existing " + ("action creator [" + mutation.updater + "] as updater for mutation [" + name + "]."));
        }
      }

      update = function update(state, action) {
        return reducer(state, _actionCreator(action.payload.data));
      };
    } else if (typeof mutation.updater === 'function') {
      update = function update(state, action) {
        return mutation.updater(state, action.payload.data);
      };
    } else if (!optimisticUpdate) {
      // Get angry only when we have no a valid optimisticUpdate
      if (process.env.NODE_ENV === 'production') {
        throw new Error('[react-rocketjump] @mutations error.');
      } else {
        throw new Error('[react-rocketjump] @mutations you should provide at least ' + ("an effect and an updater to mutation config [" + name + "]."));
      }
    } // Register updater as SUCCESS handler


    if (update) {
      var type = MUTATION_PREFIX + "/" + name + "/" + SUCCESS;
      handlers[type] = update;
    } // Optmistic updater!


    if (typeof mutation.optimisticResult === 'function') {
      // Use standard updater ans optimistiUpdater when is not defined
      if (!optimisticUpdate) {
        optimisticUpdate = update;
      }

      var _type = MUTATION_PREFIX + "/" + name + "/" + RUN;

      handlers[_type] = function (state, action) {
        var optimisticData = mutation.optimisticResult.apply(mutation, action.payload.params);
        return optimisticUpdate(state, {
          payload: {
            data: optimisticData
          }
        });
      };
    }

    return handlers;
  }, {});
  return function (prevState, action) {
    if (handleMutationsReducers[action.type]) {
      return handleMutationsReducers[action.type](prevState, action);
    }

    return reducer(prevState, action);
  };
} // Reducer for track the mutation state

function makeMutationReducer(mutation, name) {
  return function (state, action) {
    if (action.type === INIT) {
      return mutation.reducer(state, action);
    }

    var pieces = action.type.split('/');

    if (pieces.length !== 3) {
      return state;
    }

    if (pieces[0] === MUTATION_PREFIX && pieces[1] === name) {
      var decoupleType = pieces[2];
      return mutation.reducer(state, _extends({}, action, {
        type: decoupleType
      }));
    }

    return state;
  };
} // Mutations reducer or null if no mutations has a reducer config option


function makeMutationsReducer(mutations) {
  var mutationsReducers = Object.keys(mutations).reduce(function (all, name) {
    var _extends2;

    var mutation = mutations[name];

    if (typeof mutation.reducer !== 'function') {
      return all;
    }

    return _extends({}, all, (_extends2 = {}, _extends2[name] = makeMutationReducer(mutation, name), _extends2));
  }, {});

  if (Object.keys(mutationsReducers).length === 0) {
    return null;
  }

  return combineReducers(mutationsReducers);
}
var DefaultOptState = {
  snapshot: null,
  actions: []
};
function optimisticMutationsReducer(state, action) {
  if (state === void 0) {
    state = DefaultOptState;
  }

  if (state.snapshot) {
    return _extends({}, state, {
      actions: state.actions.concat({
        committed: true,
        action: action
      })
    });
  }

  return state;
}

function handleOptRun(reducer, state, action) {
  var _state$optimisticMuta = state.optimisticMutations,
      actions = _state$optimisticMuta.actions,
      snapshot = _state$optimisticMuta.snapshot;
  var nextActions = actions.concat({
    committed: false,
    action: action
  });
  var nextSnapshot = snapshot != null ? snapshot : state.root;
  var nextState = reducer(state, action);
  return _extends({}, nextState, {
    optimisticMutations: {
      snapshot: nextSnapshot,
      actions: nextActions
    }
  });
}

function applyActionsOnSnapshot(snapshot, actions, reducer) {
  var state = {
    root: snapshot
  };
  return actions.reduce(function (snap, action) {
    return reducer(snap, action);
  }, state).root;
}

function getFirstNonCommittedIndex(actions) {
  for (var i = 0; i < actions.length; i++) {
    if (!actions[i].committed) {
      return i;
    }
  }

  return null;
}

function handleOptSuccess(reducer, state, action) {
  var _state$optimisticMuta2 = state.optimisticMutations,
      actions = _state$optimisticMuta2.actions,
      snapshot = _state$optimisticMuta2.snapshot; // Commit action
  // SWAP THE RUN \W SUCCESS KEEP ORDER BUT USE SERVER RESPONSE
  // OR WHEN AUTO COMMIT ACTIVE COMMIT THE GOOD RUN!

  var mutationTypeRun = action.type.split('/').slice(0, 2).concat(RUN).join('/');
  var nextActions = actions.map(function (actionWrapper) {
    var _actionWrapper$action, _actionWrapper$action2;

    if (actionWrapper.action.type === mutationTypeRun && ((_actionWrapper$action = actionWrapper.action) == null ? void 0 : (_actionWrapper$action2 = _actionWrapper$action.meta) == null ? void 0 : _actionWrapper$action2.mutationID) === action.meta.mutationID) {
      return {
        committed: true,
        action: action.meta.mutationAutoCommit === true ? actionWrapper.action : action
      };
    } else {
      return actionWrapper;
    }
  });
  var commitedRootState;

  if (action.meta.mutationAutoCommit === true) {
    // Use current root state and commit them!
    commitedRootState = state.root;
  } else {
    // Commited root state \w SUCCESS from SERVER
    commitedRootState = applyActionsOnSnapshot(snapshot, nextActions.map(function (a) {
      return a.action;
    }), reducer);
  }

  var firstNonCommitIndex = getFirstNonCommittedIndex(nextActions);
  var nextSnapshot;

  if (firstNonCommitIndex === null) {
    // All commited!
    nextSnapshot = null;
    nextActions = [];
  } else {
    // Save a new snapshot appling actions unitl first non committed
    nextSnapshot = applyActionsOnSnapshot(snapshot, nextActions.slice(0, firstNonCommitIndex).map(function (a) {
      return a.action;
    }), reducer); // Take only action from first non committed

    nextActions = nextActions.slice(firstNonCommitIndex);
  }

  var nextState = reducer(state, action);
  return _extends({}, nextState, {
    root: commitedRootState,
    optimisticMutations: {
      snapshot: nextSnapshot,
      actions: nextActions
    }
  });
}

function handleOptFailure(reducer, state, action) {
  var _state$optimisticMuta3 = state.optimisticMutations,
      actions = _state$optimisticMuta3.actions,
      snapshot = _state$optimisticMuta3.snapshot; // Remove failied RUN

  var mutationTypeRun = action.type.split('/').slice(0, 2).concat(RUN).join('/');
  var nextActions = actions.filter(function (a) {
    var _a$action, _a$action$meta;

    return a.action.type !== mutationTypeRun || ((_a$action = a.action) == null ? void 0 : (_a$action$meta = _a$action.meta) == null ? void 0 : _a$action$meta.mutationID) !== action.meta.mutationID;
  }); // 0 - 1 - 1 - 0 - 1
  // FILTER:
  // 1 - 1 - 0 - 1
  // or
  // 0 - 1 - 1 - 1
  // Rollback to state without opt failed actions

  var roolBackRootState = applyActionsOnSnapshot(snapshot, nextActions.map(function (a) {
    return a.action;
  }), reducer);
  var firstNonCommitIndex = getFirstNonCommittedIndex(nextActions);
  var nextSnapshot;

  if (firstNonCommitIndex === null) {
    // All committed!
    nextSnapshot = null;
    nextActions = [];
  } else {
    // 0 - 1 - 1 - 1
    // Squash the action that will be removed into a new snap
    nextSnapshot = applyActionsOnSnapshot(snapshot, nextActions.slice(0, firstNonCommitIndex).map(function (a) {
      return a.action;
    }), reducer); // 0 - 1
    // or
    // 0 - 1 - 1 - 1
    // from

    nextActions = nextActions.slice(firstNonCommitIndex);
  }

  var nextState = reducer(state, action);
  return _extends({}, nextState, {
    root: roolBackRootState,
    optimisticMutations: {
      snapshot: nextSnapshot,
      actions: nextActions
    }
  });
}

function optimisticMutationsHor(reducer) {
  return function (state, action) {
    var _action$meta;

    if (Number.isInteger(action == null ? void 0 : (_action$meta = action.meta) == null ? void 0 : _action$meta.mutationID)) {
      // OPT ACTIONS
      // Split into mutations pieces
      var pieces = action.type.split('/');

      if (pieces.length === 3 && pieces[0] === MUTATION_PREFIX) {
        var decoupleType = pieces[2];

        if (decoupleType === RUN) {
          return handleOptRun(reducer, state, action);
        }

        if (decoupleType === FAILURE) {
          return handleOptFailure(reducer, state, action);
        }

        if (decoupleType === SUCCESS) {
          return handleOptSuccess(reducer, state, action);
        }
      }
    }

    return reducer(state, action);
  };
}

var COMPUTED_MUTATION_PREFIX = '@mutation';

function createWithMutationsComputeState(computed, mutations) {
  var computedKeys = Object.keys(computed);
  var mutationsSelectors = computedKeys.filter(function (k) {
    return k.indexOf(COMPUTED_MUTATION_PREFIX) === 0;
  }).reduce(function (selectors, key) {
    var _extends2;

    var path = key.substr(key.indexOf(COMPUTED_MUTATION_PREFIX) + COMPUTED_MUTATION_PREFIX.length + 1);
    var firstDot = path.indexOf('.');
    var mutationName = firstDot === -1 ? path : path.substr(0, firstDot); // Catch bad computed config before run rj

    if (mutations[mutationName] === undefined) {
      throw new Error("[react-rocketjump] you specified a non existing mutation [" + mutationName + "] " + "in your computed config.");
    } else if (mutations[mutationName].reducer === undefined) {
      throw new Error("[react-rocketjump] you specified a mutation [" + mutationName + "] " + "with no state in your computed config.");
    }

    return _extends({}, selectors, (_extends2 = {}, _extends2[key] = function (state) {
      return get(state, path);
    }, _extends2));
  }, {});
  return function computeState(state, selectors) {
    return computedKeys.reduce(function (computedState, selectorName) {
      var _extends4;

      var keyName = computed[selectorName];

      if (mutationsSelectors[selectorName]) {
        var _extends3;

        var mutationSelector = mutationsSelectors[selectorName];
        return _extends({}, computedState, (_extends3 = {}, _extends3[keyName] = mutationSelector(state.mutations), _extends3));
      }

      var selector = selectors[selectorName];

      if (selector === undefined) {
        throw new Error("[react-rocketjump] you specified a non existing selector [" + selectorName + "] " + "check your computed config.");
      }

      return _extends({}, computedState, (_extends4 = {}, _extends4[keyName] = selector(state.root), _extends4));
    }, {});
  };
}

function enancheComputeState(mutations, hasMutationsState, computeState, computed) {
  if (!hasMutationsState) {
    return computeState;
  }

  if (!computeState) {
    return function (state) {
      return state.root;
    };
  }

  var withMutationsComputeState = createWithMutationsComputeState(computed, mutations);
  return function (state, selectors) {
    return withMutationsComputeState(state, selectors);
  };
}

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}
function omit(object, props) {
  return props.reduce(function (obj, prop) {
    return del(obj, prop);
  }, object);
}
var getOrSelect = function getOrSelect(obj, selector) {
  if (typeof selector === 'function') {
    return selector(obj);
  }

  return get(obj, selector);
};

var defaultEffectCaller = function defaultEffectCaller(call) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return call.apply(void 0, args);
};

var makeRunTimeConfig = function makeRunTimeConfig(effectCaller, extraConfig) {
  var placeholderEffectCaller = extraConfig.effectCaller;
  var callEffect;
  callEffect = squashExportValue(effectCaller, [placeholderEffectCaller].filter(Boolean)); // Use default effect caller

  if (!callEffect) {
    callEffect = defaultEffectCaller;
  }

  var runTimeExtraConfig = {
    callEffect: callEffect
  };
  return runTimeExtraConfig;
}; // OOP is Just a Dream


var ExtraSideEffectSubject = /*#__PURE__*/function (_BehaviorSubject) {
  _inheritsLoose(ExtraSideEffectSubject, _BehaviorSubject);

  function ExtraSideEffectSubject(value, effectCaller) {
    var _this;

    _this = _BehaviorSubject.call(this, makeRunTimeConfig(effectCaller, value)) || this;
    _this.effectCaller = effectCaller;
    return _this;
  }

  var _proto = ExtraSideEffectSubject.prototype;

  _proto.next = function next(extraConfig) {
    return _BehaviorSubject.prototype.next.call(this, makeRunTimeConfig(this.effectCaller, extraConfig));
  };

  return ExtraSideEffectSubject;
}(BehaviorSubject);

var EffectActions = [CLEAN, RUN, CANCEL];

function filterEffectActions(action, prefix) {
  return EffectActions.map(function (a) {
    return prefix + a;
  }).indexOf(action.type) !== -1;
}

function filterNonEffectActions(action, prefix) {
  return EffectActions.map(function (a) {
    return prefix + a;
  }).indexOf(action.type) === -1;
}

function createMakeRxObservable(_ref, prefix) {
  var effectCall = _ref.effect,
      effectCaller = _ref.effectCaller,
      takeEffect = _ref.takeEffect;

  if (prefix === void 0) {
    prefix = '';
  }

  return function makeRxObservable(action$, state$, placeholderEffectCaller, prevObservable$ // <---- The observable to merge along
  ) {
    // Extra side effect configuration subject
    // used to emit changes on extra conf from outside world
    var extraSideEffectSubject = new ExtraSideEffectSubject({
      effectCaller: placeholderEffectCaller
    }, effectCaller);
    var extraSideEffectObs$ = extraSideEffectSubject.asObservable(); // Generate a result Observable from a given action
    // a RUN action but this is not checked is up to you
    // pass the corret action
    // in plus emit the PENDING action before invoke the effect
    // action => Observable(<PENDING>, <SUCCESS>|<FAILURE>)

    function mapActionToObserable(action, _ref2) {
      var callEffect = _ref2.callEffect;
      var payload = action.payload,
          meta = action.meta,
          callbacks = action.callbacks;
      var params = payload.params;
      var effectResult = callEffect.apply(void 0, [effectCall].concat(params));

      if (!(isPromise(effectResult) || isObservable(effectResult))) {
        return throwError('The effect result is expect ' + ("to be a Promise or an RxObservable but '" + effectResult + "' ") + "was given. Please check your effect and effectCaller logic.");
      }

      return concat(of({
        type: prefix + PENDING,
        meta: meta
      }), from(effectResult).pipe(map(function (data) {
        return {
          type: prefix + SUCCESS,
          payload: {
            data: data,
            params: params
          },
          meta: meta,
          // Callback runned from the subscribtion in the react hook
          successCallback: callbacks ? callbacks.onSuccess : undefined
        };
      }), catchError(function (error) {
        // Avoid headache
        if (error instanceof TypeError || error instanceof RangeError || error instanceof SyntaxError || error instanceof ReferenceError) {
          return throwError(error);
        }

        return of({
          type: prefix + FAILURE,
          payload: error,
          meta: meta,
          // Callback runned from the subscribtion in the react hook
          failureCallback: callbacks ? callbacks.onFailure : undefined
        });
      })));
    }

    var _arrayze = arrayze(takeEffect),
        effectType = _arrayze[0],
        effectTypeArgs = _arrayze.slice(1); // The prev observable to merge if no used the action$


    var mergeObservable$ = prevObservable$ ? prevObservable$ : action$;
    var dispatchObservable; // Custom take effect

    if (typeof effectType === 'function') {
      // TODO: Maybe in future check the return value of
      // custom take effect and print some warning to help
      // developers to better debugging better rj configuration
      dispatchObservable = effectType(action$, mergeObservable$, state$, extraSideEffectObs$, mapActionToObserable, prefix);
    } else {
      // Invalid effect type
      if (RxEffects[effectType] === undefined) {
        throw new Error("[react-rocketjump] takeEffect: " + takeEffect + " is an invalid effect.");
      }

      var createEffect = RxEffects[effectType]; // Apply the effect only to RUN, CLEAN and CANCEL + prefx
      // if an action different from theese is emitted simply emit/dispatch them

      dispatchObservable = merge(createEffect(action$.pipe(filter(function (a) {
        return filterEffectActions(a, prefix);
      })), state$, extraSideEffectObs$, mapActionToObserable, effectTypeArgs, prefix), mergeObservable$.pipe(filter(function (a) {
        return filterNonEffectActions(a, prefix);
      })));
    }

    return [dispatchObservable, function (config) {
      return extraSideEffectSubject.next(config);
    }];
  };
} // GioVa nel posto fa freddo brrrrrrrrrrrrr

function mergeCreateMakeRxObservable() {
  for (var _len2 = arguments.length, creators = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    creators[_key2] = arguments[_key2];
  }

  return function (action$, state$, effectCaller) {
    // TODO: Enable and test the following lines
    // when expose mergeCreateMakeRxObservable as library function
    // if (creators.length === 0) {
    //   throw new Error('You should provide at least one creator to merge.')
    // }
    var firstCreator = creators[0],
        otherCreators = creators.slice(1);

    var _firstCreator = firstCreator(action$, state$, effectCaller),
        firstDispatch$ = _firstCreator[0],
        updateConfig = _firstCreator[1];

    var _otherCreators$reduce = otherCreators.reduce(function (_ref3, rxCreator) {
      var dispatch$ = _ref3[0],
          updaters = _ref3[1];

      var _rxCreator = rxCreator(action$, state$, effectCaller, dispatch$),
          nextDispatch$ = _rxCreator[0],
          updateConfig = _rxCreator[1];

      return [nextDispatch$, updaters.concat(updateConfig)];
    }, [firstDispatch$, [updateConfig]]),
        dispatch$ = _otherCreators$reduce[0],
        configUpdaters = _otherCreators$reduce[1];

    return [dispatch$, function (config) {
      return configUpdaters.forEach(function (updateConfig) {
        return updateConfig(config);
      });
    }];
  };
}

function enhanceMakeObservable(mutations, makeObservable, parentEffectCaller) {
  var makeMutationsObsList = Object.keys(mutations).map(function (name) {
    var _mutations$name = mutations[name],
        effect = _mutations$name.effect,
        takeEffect = _mutations$name.takeEffect,
        effectCaller = _mutations$name.effectCaller;
    var prefix = MUTATION_PREFIX + "/" + name + "/";

    if (typeof effect !== 'function') {
      throw new Error('[react-rocketjump] @mutations you should provide at least ' + ("an effect and an updater to mutation config [" + name + "]."));
    }

    var mutationEffectCaller;

    if (effectCaller) {
      // If defined used the mutation effect caller
      mutationEffectCaller = effectCaller;
    } else if (effectCaller !== false && parentEffectCaller) {
      // If parent conf has effect caller us it unless is explicit set to false
      mutationEffectCaller = parentEffectCaller;
    }

    return createMakeRxObservable({
      effect: effect,
      takeEffect: takeEffect || 'every',
      effectCaller: mutationEffectCaller
    }, prefix);
  });
  return mergeCreateMakeRxObservable.apply(void 0, [makeObservable].concat(makeMutationsObsList));
}

var mutationIDCounter = 0; // Make the action creater that trigger a mutation side effects

function makeActionCreator(name, mutation) {
  var isOptimistic = typeof mutation.optimisticResult === 'function'; // Has auto commit when only optimisticUpdater is provided

  var hasAutoCommit = isOptimistic && mutation.optimisticUpdater && !mutation.updater;

  var actionCreator = function actionCreator() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }

    var meta = {
      params: params
    };

    if (isOptimistic) {
      meta.mutationID = ++mutationIDCounter;

      if (hasAutoCommit) {
        meta.mutationAutoCommit = true;
      }
    }

    return makeLibraryAction.apply(void 0, [MUTATION_PREFIX + "/" + name + "/" + RUN].concat(params)).withMeta(meta);
  };

  return actionCreator;
} // Add specials rj mutations action creators to base rj action creators


function enhanceActionCreators(mutations, actionCreators) {
  return Object.keys(mutations).reduce(function (enhancedActionCreators, name) {
    var _extends2;

    var mutation = mutations[name];
    var actionCreator = makeActionCreator(name, mutation);

    if (process.env.NODE_ENV !== 'production' && actionCreators[name]) {
      console.warn("[react-rocketjump] @mutations WARNING the mutation [" + name + "] " + "override a pre existing action creator this can leading to " + "unexpected behaviors.");
    }

    return _extends({}, enhancedActionCreators, (_extends2 = {}, _extends2[name] = actionCreator, _extends2));
  }, actionCreators);
}

function makeMutationsSelectors() {
  return {
    getRoot: function getRoot(state) {
      return state.root;
    },
    getMutation: function getMutation(state, path) {
      return get(state.mutations, path);
    }
  };
}

function enhanceMakeSelectors(mutations, makeSelectors) {
  // Compose makeSelectors as rj export does ...
  return kompose(makeSelectors, function (selectors) {
    return proxyObject(selectors, makeMutationsSelectors);
  });
}

function checkMutationsConfig(rjConfig) {
  if (typeof rjConfig.mutations === 'object' && rjConfig.mutations !== null && typeof rjConfig.effect !== 'function') {
    throw new Error('[react-rocketjump] @mutations must be defined along with effect, ' + 'please check your config.');
  }
}

function makeMutationExport(mutation) {
  if (mutation.effectCaller) {
    return _extends({}, mutation, {
      effectCaller: exportEffectCaller(undefined, mutation.effectCaller)
    });
  }

  return mutation;
}

function makeMutationsExport(mutations) {
  return Object.keys(mutations).reduce(function (mutationsExport, name) {
    var _extends2;

    return _extends({}, mutationsExport, (_extends2 = {}, _extends2[name] = makeMutationExport(mutations[name]), _extends2));
  }, {});
}

function enhanceMakeExportWithMutations(rjConfig, extendExport) {
  // Set mutations config
  if (rjConfig.mutations) {
    return _extends({}, extendExport, {
      mutations: makeMutationsExport(rjConfig.mutations)
    });
  }

  return extendExport;
}
function enhanceFinalExportWithMutations(rjObject, _ref) {
  var computed = _ref.computed,
      sideEffect = _ref.sideEffect;

  var mutations = rjObject.mutations,
      rjEnhancedObject = _objectWithoutPropertiesLoose(rjObject, ["mutations"]);

  if (!mutations) {
    return rjEnhancedObject;
  }

  var makeRxObservable = rjEnhancedObject.makeRxObservable,
      actionCreators = rjEnhancedObject.actionCreators,
      reducer = rjEnhancedObject.reducer,
      computeState = rjEnhancedObject.computeState,
      makeSelectors = rjEnhancedObject.makeSelectors;
  var enhancedReducer = enhanceReducer(mutations, reducer, actionCreators);
  var reducersToCombine = {};
  var mutationsReducer = makeMutationsReducer(mutations);

  if (mutationsReducer) {
    reducersToCombine.mutations = mutationsReducer;
  }

  var hasSomeOptimisticMutations = Object.keys(mutations).some(function (name) {
    return typeof mutations[name].optimisticResult === 'function';
  });

  if (hasSomeOptimisticMutations) {
    // Enable optimistic reducer...
    reducersToCombine.optimisticMutations = optimisticMutationsReducer;
  }

  var hasMutationsState;
  var withMutationsReducer;

  if (Object.keys(reducersToCombine).length === 0) {
    hasMutationsState = false;
    withMutationsReducer = enhancedReducer;
  } else {
    hasMutationsState = true;
    withMutationsReducer = combineReducers(_extends({
      root: enhancedReducer
    }, reducersToCombine));
  }

  if (hasSomeOptimisticMutations) {
    withMutationsReducer = optimisticMutationsHor(withMutationsReducer);
  }

  return _extends({}, rjEnhancedObject, {
    computeState: enancheComputeState(mutations, hasMutationsState, computeState, computed),
    reducer: withMutationsReducer,
    makeSelectors: enhanceMakeSelectors(mutations, makeSelectors),
    actionCreators: enhanceActionCreators(mutations, actionCreators),
    makeRxObservable: enhanceMakeObservable(mutations, makeRxObservable, sideEffect.effectCaller)
  });
}

// take a extended export (the return of this function)
// _ -> is the run config but we don't need it

var makeExport = (function (_, rjConfig, extendExport) {
  if (extendExport === void 0) {
    extendExport = {};
  }

  // Make side effect descriptor exports
  var sideEffect;

  if (!extendExport.sideEffect) {
    // Create fresh seide effect descriptor
    sideEffect = makeSideEffectDescriptor();
  } else {
    // Use the side effect descriptor form extended exports
    sideEffect = extendExport.sideEffect;
  } // Enanche side effect descriptor \w config


  sideEffect = addConfigToSideEffectDescritor(sideEffect, rjConfig); // Make reducer

  var reducer$1;

  if (!extendExport.reducer) {
    reducer$1 = reducer;
  } else {
    reducer$1 = extendExport.reducer;
  }

  if (reducer$1) {
    reducer$1 = proxyReducer(reducer$1, rjConfig.reducer);

    if (typeof rjConfig.composeReducer === 'function' || Array.isArray(rjConfig.composeReducer)) {
      var composeReducer = arrayze(rjConfig.composeReducer);
      reducer$1 = composeReducers.apply(void 0, [reducer$1].concat(composeReducer));
    }
  } // Make action creators


  var actionCreators;

  if (!extendExport.actionCreators) {
    // Make fresh action creators
    actionCreators = ActionCreators;
  } else {
    // Use actionCreators to extended export
    actionCreators = extendExport.actionCreators;
  } // Proxy actionCreators


  actionCreators = proxyObject(actionCreators, rjConfig.actions); // Create the make selectors
  // NOTE: The reason why switch from creating selectors
  // to creating a function that THEN (when rj is executed) actually
  // create selectors is a FUCKING TRICK eheh to let the user
  // to create a memoized-component version of the selectors

  var makeSelectors$1;

  if (!extendExport.makeSelectors) {
    // Fresh selectors
    makeSelectors$1 = makeSelectors;
  } else {
    // Use selectors from exports
    makeSelectors$1 = extendExport.makeSelectors;
  }

  if (makeSelectors$1) {
    makeSelectors$1 = kompose(makeSelectors$1, function (selectors) {
      return proxyObject(selectors, rjConfig.selectors);
    });
  } // Default no computed


  var computed = null;

  if (extendExport.computed) {
    // Continue the export
    computed = extendExport.computed;
  }

  if (rjConfig.computed) {
    // Merge given computed \w prev computed
    computed = _extends({}, computed, invertKeys(rjConfig.computed));
  }

  var newExport = _extends({}, extendExport, {
    sideEffect: sideEffect,
    reducer: reducer$1,
    actionCreators: actionCreators,
    makeSelectors: makeSelectors$1,
    computed: computed
  });

  return enhanceMakeExportWithMutations(rjConfig, newExport);
});

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function shouldRocketJump(partialRjsOrConfigs) {
  var hasEffectConfigured = false;

  for (var _iterator = _createForOfIteratorHelperLoose(partialRjsOrConfigs), _step; !(_step = _iterator()).done;) {
    var partialRjOrConfig = _step.value;

    // Parital allowed
    if (isPartialRj(partialRjOrConfig)) {
      continue;
    } // Rj Object not allowed


    if (isObjectRj(partialRjOrConfig)) {
      throw new Error("[react-rocketjump] you can't pass an rj object as argument.");
    } // Config object is allowed


    if (partialRjOrConfig !== null && typeof partialRjOrConfig === 'object') {
      if (typeof partialRjOrConfig.effect === 'function') {
        if (hasEffectConfigured) {
          throw new Error('[react-rocketjump] effect should be defined only once, in the last argument.');
        }

        hasEffectConfigured = true;
      }

      checkMutationsConfig(partialRjOrConfig);
      continue;
    } // A function effect


    if (typeof partialRjOrConfig === 'function') {
      if (hasEffectConfigured) {
        throw new Error('[react-rocketjump] effect should be defined only once, in the last argument.');
      }

      hasEffectConfigured = true;
      continue;
    } // Bad shit as config


    throw new Error('[react-rocketjump] you can pass only config object or rj partial to rj constructor.');
  }

  if (partialRjsOrConfigs.length === 0) {
    return false;
  }

  var lastPartialOrConfig = partialRjsOrConfigs[partialRjsOrConfigs.length - 1]; // Object \w effect configured

  if (lastPartialOrConfig !== null && typeof lastPartialOrConfig === 'object' && lastPartialOrConfig.effect) {
    return true;
  } // Is a function (and not a partial rj) rj(() => Promise.resolve(23))


  if (!isPartialRj(lastPartialOrConfig) && typeof lastPartialOrConfig === 'function') {
    return true;
  } // Not defined at last


  if (hasEffectConfigured) {
    throw new Error('[react-rocketjump] effect should be defined only once, in the last argument.');
  }

  return false;
} // Don't needed


function makeRunConfig(finalConfig) {
  return null;
}

function makeRecursionRjs(partialRjsOrConfigs, // Ingore the extra config ...
extraConfig, isLastRjInvocation) {
  var hasEffectConfigured = false;
  var recursionRjs = partialRjsOrConfigs.map(function (partialRjOrConfig) {
    if (typeof partialRjOrConfig === 'function') {
      // A Partial RJ
      if (isPartialRj(partialRjOrConfig)) {
        return partialRjOrConfig;
      } else {
        // Use as EFFECT Call
        hasEffectConfigured = true;
        return {
          effect: partialRjOrConfig
        };
      }
    }

    hasEffectConfigured = hasEffectConfigured || typeof partialRjOrConfig.effect === 'function';
    return partialRjOrConfig;
  });

  if (!hasEffectConfigured && isLastRjInvocation) {
    throw new Error("[react-rocketjump] you can't invoke a partialRj.");
  }

  return recursionRjs;
}

function finalizeExport(mergegAlongExport, runConfig, finalConfig) {
  // ~~ END OF RECURSION CHAIN  ~~
  var sideEffect = mergegAlongExport.sideEffect,
      computed = mergegAlongExport.computed,
      rjExport = _objectWithoutPropertiesLoose(mergegAlongExport, ["sideEffect", "computed"]);

  var effectPipeline = sideEffect.effectPipeline,
      sideEffectConfig = _objectWithoutPropertiesLoose(sideEffect, ["effectPipeline"]); // Create the make rx observable function using merged side effect descriptor!


  var makeRxObservable = createMakeRxObservable(sideEffectConfig);

  var pipeActionStream = function pipeActionStream(action$, state$) {
    return effectPipeline.reduce(function (action$, piper) {
      return piper(action$, state$);
    }, action$);
  }; // Create the compute state function by computed config,
  // when no computed config is given return null is responsibility
  // of useRj, connectRj, .. to check for null


  var computeState = createComputeState(computed);

  var finalExport = _extends({}, rjExport, {
    computeState: computeState,
    makeRxObservable: makeRxObservable,
    pipeActionStream: pipeActionStream
  }); // Finally the rocketjump runnable state is created!

  /*
    {
      reducer: fn,
      computeState: fn|null
      actionCreators: {},
      makeSelectors: fn,
      makeRxObservable: fn,
      pipeActionStream: fn,
    }
  */


  return enhanceFinalExportWithMutations(finalExport, mergegAlongExport);
}

var rj = forgeRocketJump({
  shouldRocketJump: shouldRocketJump,
  makeRunConfig: makeRunConfig,
  makeRecursionRjs: makeRecursionRjs,
  makeExport: makeExport,
  finalizeExport: finalizeExport
});

export { CLEAN as C, FAILURE as F, INIT as I, PENDING as P, RJ_CONFIG_PLACEHOLDER as R, SUCCESS as S, UPDATE_DATA as U, RxEffects as a, RUN as b, CANCEL as c, getOrSelect as g, omit as o, rj as r };
