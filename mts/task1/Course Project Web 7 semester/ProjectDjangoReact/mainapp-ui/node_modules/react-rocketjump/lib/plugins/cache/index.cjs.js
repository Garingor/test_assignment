'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var rocketjumpCore = require('rocketjump-core');
var rj = require('../../rj-5794e05d.js');
var rxjs = require('rxjs');
var operators = require('rxjs/operators');
require('rocketjump-core/utils');
require('@babel/runtime/helpers/inheritsLoose');
require('object-path-immutable');
require('../../index.cjs.js');
require('react');
require('../../debugger-1b0f24ff.js');
require('hoist-non-react-statics');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);

var LRUCache = /*#__PURE__*/function () {
  function LRUCache(namespace, size, store) {
    this.namespace = namespace;
    this.size = size;
    this.store = store;
  }

  var _proto = LRUCache.prototype;

  _proto._effectiveKey = function _effectiveKey(key) {
    return this.namespace + "-" + key;
  };

  _proto._meta = function _meta() {
    var m = this.store.getItem("$" + this.namespace + "-meta");

    if (m) {
      return _extends__default['default']({}, m);
    } else {
      return {
        count: 0,
        lru: [],
        dict: {}
      };
    }
  };

  _proto._setMeta = function _setMeta(nextMeta) {
    this.store.setItem("$" + this.namespace + "-meta", nextMeta);
  };

  _proto._resetMeta = function _resetMeta() {
    this.store.removeItem("$" + this.namespace + "-meta");
  };

  _proto.has = function has(key) {
    var realKey = this._effectiveKey(key);

    return !!this._meta().dict[realKey];
  };

  _proto.get = function get(key) {
    var realKey = this._effectiveKey(key);

    var meta = this._meta();

    if (!!meta.dict[realKey]) {
      meta.lru = [].concat(meta.lru.filter(function (key) {
        return key !== realKey;
      }), [realKey]);

      this._setMeta(meta);

      return this.store.getItem(realKey);
    } else {
      return undefined;
    }
  };

  _proto.set = function set(key, value) {
    var realKey = this._effectiveKey(key);

    var meta = this._meta();

    if (meta.count === this.size) {
      var keyToDelete = meta.lru.shift();
      this.store.removeItem(keyToDelete);
      delete meta.dict[keyToDelete];
      meta.count--;
    }

    meta.dict[realKey] = 1;
    meta.count++;
    meta.lru = [].concat(meta.lru, [realKey]);

    this._setMeta(meta);

    this.store.setItem(realKey, value);
  };

  _proto.clear = function clear() {
    var _this = this;

    var meta = this._meta();

    Object.keys(meta.dict).forEach(function (key) {
      _this.store.removeItem(key);
    });

    this._resetMeta();
  };

  return LRUCache;
}();
var FIFOCache = /*#__PURE__*/function () {
  function FIFOCache(namespace, size, store) {
    this.namespace = namespace;
    this.size = size;
    this.store = store;
  }

  var _proto2 = FIFOCache.prototype;

  _proto2._effectiveKey = function _effectiveKey(key) {
    return this.namespace + "-" + key;
  };

  _proto2._meta = function _meta() {
    var m = this.store.getItem("$" + this.namespace + "-meta");

    if (m) {
      return _extends__default['default']({}, m);
    } else {
      return {
        count: 0,
        queue: [],
        dict: {}
      };
    }
  };

  _proto2._setMeta = function _setMeta(nextMeta) {
    this.store.setItem("$" + this.namespace + "-meta", nextMeta);
  };

  _proto2._resetMeta = function _resetMeta() {
    this.store.removeItem("$" + this.namespace + "-meta");
  };

  _proto2.has = function has(key) {
    var realKey = this._effectiveKey(key);

    return !!this._meta().dict[realKey];
  };

  _proto2.get = function get(key) {
    var realKey = this._effectiveKey(key);

    var meta = this._meta();

    if (!!meta.dict[realKey]) {
      return this.store.getItem(realKey);
    } else {
      return undefined;
    }
  };

  _proto2.set = function set(key, value) {
    var realKey = this._effectiveKey(key);

    var meta = this._meta();

    if (meta.count === this.size) {
      var keyToDelete = meta.queue.shift();
      this.store.removeItem(keyToDelete);
      delete meta.dict[keyToDelete];
      meta.count--;
    }

    meta.dict[realKey] = 1;
    meta.count++;
    meta.queue = [].concat(meta.queue, [realKey]);

    this._setMeta(meta);

    this.store.setItem(realKey, value);
  };

  _proto2.clear = function clear() {
    var _this2 = this;

    var meta = this._meta();

    Object.keys(meta.dict).forEach(function (key) {
      _this2.store.removeItem(key);
    });

    this._resetMeta();
  };

  return FIFOCache;
}();

var BACKEND = {};
var InMemoryStore = /*#__PURE__*/function () {
  function InMemoryStore() {}

  var _proto = InMemoryStore.prototype;

  _proto.getItem = function getItem(key) {
    return BACKEND[key];
  };

  _proto.setItem = function setItem(key, value) {
    BACKEND[key] = value;
  };

  _proto.removeItem = function removeItem(key) {
    delete BACKEND[key];
  };

  return InMemoryStore;
}();
var clearInMemoryStore = function clearInMemoryStore() {
  for (var k in BACKEND) {
    delete BACKEND[k];
  }
};
var SessionStorageStore = /*#__PURE__*/function () {
  function SessionStorageStore() {}

  var _proto2 = SessionStorageStore.prototype;

  _proto2.getItem = function getItem(key) {
    var v = sessionStorage.getItem(key);

    if (v) {
      return JSON.parse(v);
    }

    return v;
  };

  _proto2.setItem = function setItem(key, value) {
    sessionStorage.setItem(key, JSON.stringify(value));
  };

  _proto2.removeItem = function removeItem(key) {
    sessionStorage.removeItem(key);
  };

  return SessionStorageStore;
}();
var LocalStorageStore = /*#__PURE__*/function () {
  function LocalStorageStore() {}

  var _proto3 = LocalStorageStore.prototype;

  _proto3.getItem = function getItem(key) {
    var v = localStorage.getItem(key);

    if (v) {
      return JSON.parse(v);
    }

    return v;
  };

  _proto3.setItem = function setItem(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  };

  _proto3.removeItem = function removeItem(key) {
    localStorage.removeItem(key);
  };

  return LocalStorageStore;
}();

var defaultKey = function defaultKey() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return JSON.stringify(args);
};

var rjCache = function rjCache(config) {
  if (!config.ns) {
    throw new Error('RjCache requires the ns property to be set');
  }

  if (config.ns.includes('$')) {
    throw new Error('RjCache ns cannot contain the $ symbol');
  }

  if (!config.size) {
    throw new Error('RjCache needs a cache size to be defined');
  }

  var ns = config.ns;
  var size = config.size;
  var store = new (config.store || SessionStorageStore)();
  var provider = new (config.provider || LRUCache)(ns, size, store);
  var key = config.key || defaultKey;
  return rj.rj({
    actions: function actions() {
      return {
        resetCache: function resetCache() {
          return rocketjumpCore.makeLibraryAction('$reset-cache');
        }
      };
    },
    effectCaller: function effectCaller(effectFn) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var k = key.apply(void 0, args);

      if (provider.has(k)) {
        return rxjs.of(provider.get(k));
      } else {
        return rxjs.from(effectFn.apply(void 0, args)).pipe(operators.map(function (result) {
          provider.set(k, result);
          return result;
        }));
      }
    },
    effectPipeline: function effectPipeline(action$) {
      return action$.pipe(operators.tap(function (action) {
        if (action.type === '$reset-cache') {
          provider.clear();
        }
      }), operators.filter(function (action) {
        return action.type !== '$reset-cache';
      }));
    }
  });
};

exports.FIFOCache = FIFOCache;
exports.InMemoryStore = InMemoryStore;
exports.LRUCache = LRUCache;
exports.LocalStorageStore = LocalStorageStore;
exports.SessionStorageStore = SessionStorageStore;
exports.clearInMemoryStore = clearInMemoryStore;
exports.default = rjCache;
