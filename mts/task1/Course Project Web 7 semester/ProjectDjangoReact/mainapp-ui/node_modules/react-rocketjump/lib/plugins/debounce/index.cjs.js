'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
require('rocketjump-core');
var rj = require('../../rj-5794e05d.js');
var rxjs = require('rxjs');
var operators = require('rxjs/operators');
require('rocketjump-core/utils');
require('@babel/runtime/helpers/inheritsLoose');
require('object-path-immutable');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);

var defaultOptions = {
  time: 180
};

var rjDebounce = function rjDebounce(optionsOrTime) {
  if (optionsOrTime === void 0) {
    optionsOrTime = defaultOptions;
  }

  var options;

  if (typeof optionsOrTime === 'number' && isFinite(optionsOrTime)) {
    options = {
      time: optionsOrTime
    };
  } else {
    options = _extends__default['default']({}, defaultOptions, optionsOrTime);
  }

  return rj.rj({
    actions: function actions(_ref) {
      var run = _ref.run;
      return {
        runDebounced: function runDebounced() {
          return run.apply(void 0, arguments).withMeta({
            debounced: true
          });
        }
      };
    },
    effectPipeline: function effectPipeline(action$) {
      return action$.pipe(operators.scan(function (prev, current) {
        // Shoud debounce ma run?
        if (current.type === rj.RUN && current.meta && current.meta.debounced && typeof options.when === 'function') {
          var shouldDebounce = options.when(prev ? prev.payload.params : null, current.payload.params);

          var newMeta = _extends__default['default']({}, current.meta);

          if (shouldDebounce) {
            newMeta.debounced = true;
          } else {
            newMeta.debounced = false;
          }

          return _extends__default['default']({}, current, {
            meta: newMeta
          });
        }

        return current;
      }, null), operators.debounce(function (action) {
        if (action.type === rj.RUN && action.meta.debounced) {
          return rxjs.timer(options.time);
        } else {
          return rxjs.empty();
        }
      }), operators.distinctUntilChanged(function (prevAction, currAction) {
        // not same stuff
        if (currAction.type !== prevAction.type) {
          return false;
        } // Ignore not debounced actions...


        if (currAction.type !== rj.RUN || !currAction.meta.debounced) {
          return false;
        } // cant be the same


        if (currAction.payload.params.length !== prevAction.payload.params.length) {
          return false;
        } // TODO: Maybe deep compare at 1 level depth of plain objects
        // compare params


        for (var i = 0; i < currAction.payload.params.length; i++) {
          if (currAction.payload.params[i] !== prevAction.payload.params[i]) {
            return false;
          }
        } // the same action =)


        return true;
      }));
    }
  });
};

exports.default = rjDebounce;
